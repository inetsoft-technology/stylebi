/* SQLParser */
header
{
/*
 * Copyright (c) 1996-2003, InetSoft Technology Corp, All Rights Reserved.
 *
 * The software and information contained herein are copyrighted and
 * proprietary to InetSoft Technology Corp. This software is furnished
 * pursuant to a written license agreement and may be used, copied,
 * transmitted, and stored only in accordance with the terms of such
 * license and with the inclusion of the above copyright notice. Please
 * refer to the file "COPYRIGHT" for further copyright and licensing
 * information. This software and information or any other copies
 * thereof may not be provided or otherwise made available to any other
 * person.
 */

package inetsoft.uql.util.sqlparser ;
}

{

import java.io.*;
import inetsoft.uql.jdbc.*;
import inetsoft.uql.util.*;
import inetsoft.util.*;
import java.util.*;
import java.security.*;

class Main {
        private static long ots = 0;
        public static String now() {
            long ts = System.currentTimeMillis();

            if(ots == 0) {
                ots = ts;
            }

            return new java.sql.Time(ts) + "[ms:" + ts + "]" +
                   "[diff:" + (ts - ots) + "]";
        }

        public static void main(String[] args) {
            UniformSQL sql = new UniformSQL();
            boolean debug = false;
            boolean onlySelect = false;
            boolean onlySelectFrom = false;
            boolean onlyExpression = false;

            if(args.length > 1 && args[1] != null) {
                if(args[1].equals("-d")) {
                    debug = true;
                }
                else if(args[1].equals("-s")) {
                    onlySelect = true;
                }
                else if(args[1].equals("-sf")) {
                    onlySelectFrom = true;
                }
                else if(args[1].equals("-exp")) {
                    onlyExpression = true;
                }
            }

            System.out.println(now());

            try {
                SQLLexer lexer;
                if(args.length > 0) {
                    lexer = new SQLLexer(new FileInputStream(args[0]));
                }
                else {
                    lexer = new SQLLexer(new DataInputStream(System.in));
                }

                SQLParser parser = new SQLParser(lexer);
                //parser.select_stmt_single_row(sql);
                //sql.setDataSourceType("oracle");
                if(debug) {
                    parser.direct_select_stmt_n_rows_debug(sql);
                }
                else {
                    if(onlySelect) {
                        parser.only_select(sql);
                    }
                    else if(onlySelectFrom) {
                        parser.only_select_from(sql);
                    }
                    else if(onlyExpression) {
                        parser.value_exp();
                    }
                    else {
                        parser.direct_select_stmt_n_rows(sql);
                    }
                }

                System.out.println("oracle:" + sql.getSQLString());
                PrintWriter writer = null;

/*
                        sql.setDataSourceType("access");
                        System.out.println("access:" + sql.getSQLString());
                        sql.setDataSourceType("odbc");
                        System.out.println(sql.getSQLString());
*/
                try {
                    writer = new PrintWriter(
                        new FileOutputStream("c:\\parserresult.xml"), true);
                } catch(Exception e) {
                    e.printStackTrace();
                    System.exit(0);
                }

                sql.writeXML(writer);
                writer.close();

            } catch(Exception e) {
                System.err.println(sql.getSQLString());
                System.err.println("exception:"+e);
                e.printStackTrace();
            }

            System.out.println(now());
        }
    }
}

/**
 * This Class is generated by antlr base on grammar file SQLParser.g.
 * NOTE: when add or modify a rule, REMEMBER to call checkStatus to make sure
 * that we could stop sql parser when we hope to. Please refer to other rules
 * for detailed information on this issue.
 */
class SQLParser extends Parser;
options {
        defaultErrorHandler = false;     // Don't generate parser error handlers
        codeGenBitsetTestThreshold = 3;  // Some optimizations
        k = 3;
}

{
private UniformSQL uniSql = null;
private int sequence = 0;
private boolean hasField = false;
private Set columns = new HashSet();
private long ts = -1; // stop timestamp
private int checkCnt = 0; // optimization
private Map map = new HashMap(); // sql + table ->op
private boolean catalog = false;
private boolean schema = true;
private boolean preferQuote = true;

private static class TableKey {
   public TableKey(UniformSQL sql, Object table) {
      this.sql = sql;
      this.table = table;
   }

   public boolean equals(Object obj) {
      if(!(obj instanceof TableKey)) {
         return false;
      }

      TableKey key2 = (TableKey) obj;
      return key2.sql == sql && key2.table.equals(table);
   }

   public int hashCode() {
      return sql.hashCode() + table.hashCode();
   }

   public String toString() {
      return sql.hashCode() + "[" + table + "]";
   }

   private UniformSQL sql;
   private Object table;
}

private void setTableOp(UniformSQL sql, Object table, String op) {
   if(op == null) {
      return;
   }

   if(op.length() >= 4 && op.substring(0, 4).equalsIgnoreCase("LEFT") ||
      op.length() >= 5 && op.substring(0, 5).equalsIgnoreCase("RIGHT"))
   {
      map.put(new TableKey(sql, table), op);
   }
}

private boolean isSameTable(String expr1, String expr2) {
   if(expr1.equals(expr2)) {
      return true;
   }

   if(uniSql != null) {
      SQLHelper helper = SQLHelper.getSQLHelper(uniSql.getDataSource());

      for(int i = 0; i < uniSql.getTableCount(); i++) {
         String tableName = Tool.toString(uniSql.getSelectTable(i).getName());
         String tableAlias = uniSql.getSelectTable(i).getAlias();
         String quotedTableAlias = !Tool.equals(tableAlias, tableName) ?
            XUtil.quoteAlias(tableAlias, helper) : helper.quoteTableName(tableAlias);
         String prefix = quotedTableAlias + ".";

         if(expr1.startsWith(prefix) && expr2.startsWith(prefix)) {
            return true;
         }
      }
   }

   return false;
}

private String getTableOp(UniformSQL sql, Object table) {
   return (String) map.get(new TableKey(sql, table));
}

private void clearTableOps() {
    map.clear();
}

public boolean hasField(){
   return hasField;
}

public String[] getColumns() {
   String arr[] = new String[columns.size()];
   columns.toArray(arr);
   return arr;
}

public void setTime(long last) {
   this.ts = last + System.currentTimeMillis();
}

private void checkStatus() {
   checkCnt++;

   if(checkCnt > 5000) {
      checkCnt = 0;

      if(ts > 0 && System.currentTimeMillis() >= ts) {
         throw new ParserStoppedException();
      }
   }
}

public String getUniqueName() {
   return Integer.toString(sequence++);
}

public boolean isCatalogEnabled() {
   return catalog;
}

public void setCatalogEnabled(boolean catalog) {
   this.catalog = catalog;
}

public boolean isSchemaEnabled() {
   return schema;
}

public void setSchemaEnabled(boolean schema) {
   this.schema = schema;
}

public void setPreferQuote(boolean preferQuote) {
   this.preferQuote = preferQuote;
}

public static boolean isQualifiedName(String name) {
   // @by larryl 2003-9-22
   // make sure we handle the space in table/column names, if we
   // don't remove space, it will be treated as an expression
   // since the parser won't parse the name correctly
   name = Tool.replaceAll(name, " ", "");

   // @by larryl, replace quotes in table (e.g. "my.table".col1) so it would
   // not be treated as an expression
   StringBuffer buf = new StringBuffer();
   boolean inQuote = false;

   for(int i = 0; i < name.length(); i++) {
      if(name.charAt(i) == '"') {
         inQuote = !inQuote;
         continue;
      }

      if(inQuote) {
         char ch = name.charAt(i);

         if(ch == '.') {
            ch = '_';
         }

         buf.append(ch);
      }
      else {
         buf.append(name.charAt(i));
      }
   }

   name = buf.toString();

   try {
      SQLLexer lexer = new SQLLexer(new StringReader(name));

      SQLParser parser = new SQLParser(lexer);
      String qname = parser.column_ref();

      if(name.equals(qname)) {
        return true;
      }
   }
   catch(Exception e) {
   }

   return false;
}

/**
* Change token type to specified type.
*/
public boolean changeType(String targetStr, int type) {
   try {
           if(LT(1).getText().trim().equalsIgnoreCase(targetStr)) {
                LT(1).setType(type);
                return true;
           }
   }
   catch(Exception e) {
   }

   return false;
}

public int getDatabaseType() {
   if(uniSql != null && uniSql.getDataSource() != null) {
      return uniSql.getDataSource().getDatabaseType();
   }

   return -1;
}

// strip quote
String strip(String str) {
    int last = (str != null) ? str.length() - 1 : 0;
    return (str != null && str.length() > 1 &&
            (str.charAt(0)=='\'' && str.charAt(last)=='\'' ||
             str.charAt(0)=='"' && str.charAt(last)=='"'))
        ? str.substring(1, str.length()-1) : str;
}

// quote string if it contains dot
String quoteDot(String str) {
   JDBCDataSource dx = null;

   if(uniSql != null) {
      dx = uniSql.getDataSource();
   }

   SQLHelper helper = SQLHelper.getSQLHelper(dx, (Principal) null);
   String quote = helper != null ? helper.getQuote() : "\"";

   if(str.indexOf(".") > 0 || preferQuote && XUtil.isSpecialName(str, true, helper) &&
      !XUtil.shouldNotQuote(str))
   {
      return quote + strip(str) + quote;
   }

   return str;
}
}

schema_identifier returns [String schmid = ""]
        {String tmp;  {checkStatus();}}
        :
        (
        a:IDENT         { schmid = a.toString(); }
        | schmid = special_identifier
        )
        ;

special_identifier returns [String specid = ""]
        {String tmp = ""; XExpression exp = null; {checkStatus();}}
        :
        a:SPIDENT {tmp = a.getText();specid = tmp.substring(1, tmp.length() - 1);}
        |c:SPIDENT2 {tmp = c.getText();specid = tmp.substring(1, tmp.length() - 1);}
        |d:SPIDENT_VAR {specid = d.getText();}
        |b:SPIDENT_SQUARE {
            tmp = b.getText();

            if(getDatabaseType() == JDBCDataSource.JDBC_CLICKHOUSE) {
               specid = tmp;
            }
            else {
               specid = tmp.substring(1, tmp.length() - 1);
            }
        }
    |h:SPIDENT_BRACKET {specid = h.getText();}
        |(DOLAR (f:IDENT|g:UNSIGNED_NUM_LIT)  {specid = "$" + ((f!=null)?f.getText():g.getText());})
        ;

comparison_operator returns [String comp = ""]
        {checkStatus();}
        :
        (
          a:LT_         {comp += a.getText();}
        | b:GT          {comp += b.getText();}
        | c:LE          {comp += c.getText();}
        | d:GE          {comp += d.getText();}
        | e:EQ          {comp += e.getText();}
        | f:NE          {comp += f.getText();}
        | g:NEQ         {comp += g.getText();}
        | h:LJ          {comp += h.getText();}
        | i:RJ          {comp += i.getText();}
        | k:OJ l:EQ     {comp += k.getText() + l.getText();}
        )
        ;

/*  Rebuild the condition  */

search_condition returns [XFilterNode node = null]
        {XFilterNode tmp, tmp1; {checkStatus();}}
        :
        tmp = boolean_term
        (
        //( OR)=>
        ( OR tmp1 = search_condition
        {node = new XSet("or"); tmp.setName(getUniqueName()); tmp1.setName(getUniqueName());
        node.addChild(tmp); node.addChild(tmp1);}
        )
        )?
        {if(node == null) {node = tmp;}}
        ;

boolean_term returns [XFilterNode node = null]
        {XFilterNode tmp, tmp1; {checkStatus();}}
        :
        tmp = boolean_factor
        (
        //( AND)=>
        ( AND tmp1 = boolean_term
        {node = new XSet("and"); tmp.setName(getUniqueName()); tmp1.setName(getUniqueName());
        node.addChild(tmp); node.addChild(tmp1);}
        )
        )?
        {if(node == null) {node = tmp;}}
        ;

boolean_factor returns [XFilterNode node = null]
        {boolean isnot = false; {checkStatus();}}
        :
        (NOT {isnot = true;})? node = boolean_test
        {if(isnot == true){
                node.setIsNot(true);
        }
        }
        ;

boolean_test returns [XFilterNode node = null]
        {XFilterNode tmp; String relation = "", str;
        XUnaryCondition uc = new XUnaryCondition(); {checkStatus();}}
        :
        tmp = boolean_primary
        ( a:IS {relation = a.getText();}( b:NOT {relation += " " + b.getText();})?
        str = truth_value
        {XExpression exp = new XExpression(); exp.setValue(str,XExpression.EXPRESSION);
        uc.setExpression1(exp); uc.setOp("");}
        )?
        {if(!relation.equals("")) {
                node = new XSet(relation);
                tmp.setName(getUniqueName());
                uc.setName(getUniqueName());
                node.addChild(tmp);
                node.addChild(uc);
        }
        else {tmp.setName(getUniqueName()); node = tmp;}
        }
        ;

truth_value returns [String tv = ""]
        {checkStatus();}
        :
        a:TRUE {tv = a.getText();}
        | b:FALSE {tv = b.getText();}
        | c:UNKNOWN {tv = c.getText();}
        ;

boolean_primary returns [XFilterNode node = null]
        {checkStatus();}
        :
        (OPEN_PAREN (NOT)? boolean_primary)=>
        ( OPEN_PAREN node = search_condition CLOSE_PAREN )
        |node = predicate
        ;

predicate returns [XFilterNode node = null]
        {checkStatus();}
        :
        (row_value_constructor comp_op quantifier)=>
        node = quantified_comp_predicate
        |
        (row_value_constructor comp_op)=>
        node = comp_predicate
        |
        (row_value_constructor (NOT)? BETWEEN)=>
        node = between_predicate
        |
        (row_value_constructor ( NOT )? IN)=>
        node = in_predicate
        |
        (match_value ( NOT)? LIKE)=>
        node = like_predicate
        |
        //(match_value ( NOT )? SIMILAR)=>
        //node = similar_predicate
        //|
        (null_predicate)=>
        node = null_predicate
        |
        (regexp_predicate)=>
        node = regexp_predicate
        |
        node = exists_predicate
        |
        node = unique_predicate
        |
        (row_value_constructor MATCH)=>
        node = match_predicate
        |
        (match_value ( NOT)? MATCHES)=>
        node = matches_predicate
        |
        node = overlaps_predicate
        |
        node = quantified_predicate
        ;

comp_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2; String op; XBinaryCondition node;
        boolean isOracleLeftJoin = false; {checkStatus();}}
        :
        exp1 = row_value_constructor op = comp_op exp2 = row_value_constructor
        ((OJ)=>OJ {isOracleLeftJoin = true;}|)
        {
        // right outer join?
        if(op.equals("(+)=")) {
                op = "=*";
        }

        // left outer join?
        if(isOracleLeftJoin == true) {
                op = "*=";
        }

        if(exp1.getType().equals(XExpression.FIELD) &&
                exp2.getType().equals(XExpression.FIELD) &&
                !isSameTable(exp1.getValue().toString(), exp2.getValue().toString()) &&
                !((String)exp1.getValue()).startsWith("$") &&
                !((String)exp2.getValue()).startsWith("$") &&
                (op.equals("=") || op.equals(">") || op.equals("<") || op.equals(">=")
                 || op.equals("<=") || op.equals("!=") || op.equals("<>")
                 || op.equals("*=") || op.equals("=*") )) {
                node = new XJoin();
        }
        else {
                node = new XBinaryCondition();
        }

        node.setExpression1(exp1);
        node.setOp(op); node.setExpression2(exp2); xnode = node;}
        ;

comp_op returns [String op = ""]
        {checkStatus();}
        :
        op = comparison_operator
        ;

between_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2, exp3; String op = ""; boolean isnot = false;
        XTrinaryCondition node; {checkStatus();}}
        :
        exp1 = row_value_constructor (NOT {isnot = true;})? a:BETWEEN {op = a.getText();}
        exp2 = row_value_constructor AND exp3 = row_value_constructor
        {node = new XTrinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2);node.setExpression3(exp3);
        node.setOp(op); if(isnot == true){node.setIsNot(true);} xnode = node;}
        ;

in_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2; boolean isnot = false; String op = "";
        XBinaryCondition node; {checkStatus();}}
        :
        exp1 = row_value_constructor
        ( NOT {isnot = true;})? a:IN {op = a.getText();} exp2 = in_predicate_value
        {node = new XBinaryCondition(); node.setExpression1(exp1); node.setOp(op);
        node.setExpression2(exp2);
        if(isnot == true){node.setIsNot(true);} xnode = node;}
        ;

in_predicate_value returns [XExpression exp = null]
        {XExpression tmp; {checkStatus();}}
        :
        (OPEN_PAREN in_value_list )=>
        OPEN_PAREN tmp = in_value_list CLOSE_PAREN
        {exp = new XExpression(); exp.setValue("(" + tmp.toString() + ")",XExpression.EXPRESSION);}
        |exp = table_subquery
        ;

table_subquery returns [XExpression exp = null]
        {checkStatus();}
        :
        //exp = subquery
        OPEN_PAREN
        exp = query_spec
        CLOSE_PAREN
        ;

in_value_list returns [XExpression exp = null]
        {XExpression tmp; String str = ""; {checkStatus();}}
        :
        tmp = value_exp {str = tmp.toString();}
        ( COMMA tmp = value_exp {str += "," + tmp.toString();})*
        {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        ;

like_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2, texp; boolean isnot = false; String op = "", expstr = "";
        XBinaryCondition node; {checkStatus();}}
        :
        exp1 = match_value ( NOT {isnot = true;})? a:LIKE {op = a.getText();}
        texp = pattern {expstr = texp.toString();}
        ( b:ESCAPE texp = escape_char {expstr +=" " + b.getText() + " " + texp.toString();})?

        {exp2 = new XExpression(); exp2.setValue(expstr, XExpression.EXPRESSION);
        node = new XBinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2); node.setOp(op);
        if(isnot == true){node.setIsNot(true);} xnode = node;}
        ;

matches_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2, texp; boolean isnot = false; String op = "", expstr = "";
        XBinaryCondition node; {checkStatus();}}
        :
        exp1 = match_value ( NOT {isnot = true;})? a:MATCHES {op = a.getText();}
        texp = pattern
        {expstr = "\"" + texp.toString() + "\""; /*restore double quote of matches pattern*/}
        ( b:ESCAPE texp = escape_char {expstr +=" " + b.getText() + " " + texp.toString();})?

        {exp2 = new XExpression(); exp2.setValue(expstr, XExpression.EXPRESSION);
        node = new XBinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2); node.setOp(op);
        if(isnot == true){node.setIsNot(true);} xnode = node;}
        ;

regexp_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2, texp; boolean isnot = false; String op = "", expstr = "";
        XBinaryCondition node; {checkStatus();}}
        :
        exp1 = match_value ( NOT {isnot = true;})? a:REGEXP {op = a.getText();}
        expstr = schema_name
        ( b:ESCAPE texp = escape_char {expstr +=" " + b.getText() + " " + texp.toString();})?

        {exp2 = new XExpression(); exp2.setValue(expstr, XExpression.EXPRESSION);
        node = new XBinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2); node.setOp(op);
        if(isnot == true){node.setIsNot(true);} xnode = node;}
        ;

/* Remove similar predicate to remove TO keyword
similar_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2, texp; boolean isnot = false; String op = "", expstr = "";
        XBinaryCondition node; {checkStatus();}}
        :
        exp1 = match_value ( NOT {isnot = true;})? a:SIMILAR {op = a.getText();} b:TO {op += " " + b.getText();}
        texp = pattern {expstr = texp.toString();}
        ( c:ESCAPE texp = escape_char {expstr +=" " + c.getText() + " " + texp.toString();})?

        {exp2 = new XExpression(); exp2.setValue(expstr, XExpression.EXPRESSION);
        node = new XBinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2); node.setOp(op);
        if(isnot == true){node.setIsNot(true);} xnode = node;}
        ;
*/

match_value returns [XExpression exp = null]
        {String str; {checkStatus();}}
        :
        str = char_value_exp {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        ;

pattern returns [XExpression exp = null]
        {String str; {checkStatus();}}
        :
        str = char_value_exp {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        ;

escape_char returns [XExpression exp = null]
        {String str; {checkStatus();}}
        :
        str = char_value_exp {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        ;

null_predicate returns [XFilterNode xnode = null]
        {XExpression exp; String op = ""; boolean isnot = false; XUnaryCondition node; {checkStatus();}}
        :
        exp = row_value_constructor a:IS ( NOT {isnot = true;})? b:NULL
        {op = a.getText() + " " + b.getText();}
        {node = new XUnaryCondition(); node.setExpression1(exp);
        node.setOp(op); if(isnot == true) {node.setIsNot(true);} xnode = node;}
        ;

quantified_comp_predicate returns [XFilterNode xnode =null]
        {XExpression exp1, exp2, tmp; String op, str; XBinaryCondition node; {checkStatus();}}
        :
        exp1 = row_value_constructor op = comp_op str = quantifier tmp = table_subquery

        {exp2 = new XExpression(); exp2.setValue(str + " " + tmp, XExpression.EXPRESSION);
        node = new XBinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2); node.setOp(op); xnode = node;}
        ;

quantified_predicate returns [XFilterNode xnode = null]
        {String op = "", str, tmp; XExpression exp1, exp2; XFilterNode node;
        XBinaryCondition tnode; {checkStatus();}}
        :
        a:FOR tmp = quantifier {op = a.getText() + " " + tmp;}
        exp1 = row_value_constructor OPEN_PAREN node = search_condition CLOSE_PAREN
        {exp2 = new XExpression(); exp2.setValue("(" + node.toString() + ")", XExpression.EXPRESSION);
        tnode = new XBinaryCondition(); tnode.setExpression1(exp1);
        tnode.setExpression2(exp2); tnode.setOp(op); xnode = tnode;}
        ;

quantifier returns [String quant = ""]
        {checkStatus();}
        :
        a:ALL {quant = a.getText();}
        | b:SOME {quant = b.getText();}
        | c:ANY {quant = c.getText();}
        ;

exists_predicate returns [XFilterNode xnode = null]
        {XExpression exp; String op; XUnaryCondition node; {checkStatus();}}
        :
        a:EXISTS exp = table_subquery

        {op = a.getText();
        node = new XUnaryCondition(); node.setExpression1(exp); node.setOp(op);
        xnode = node;}
        ;

unique_predicate returns [XFilterNode xnode = null]
        {XExpression exp; String op; XUnaryCondition node; {checkStatus();}}
        :
        a:UNIQUE exp = table_subquery

        {op = a.getText();
        node = new XUnaryCondition(); node.setExpression1(exp); node.setOp(op);
        xnode = node;}
        ;

match_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2 = null;
         String op = "", str; XBinaryCondition node; {checkStatus();}}
        :
        exp1 = row_value_constructor a:MATCH {op = a.getText();}
        ( b:UNIQUE {op += " " + b.getText();})?
        ( c:PARTIAL {op += " " + c.getText();}
        | d:FULL {op += " " + d.getText();}
        | e:SIMPLE {op += " " + e.getText();}
        )?
        exp2 = table_subquery

        {node = new XBinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2); node.setOp(op); xnode = node;}
        ;

overlaps_predicate returns [XFilterNode xnode = null]
        {XExpression exp1, exp2; String op = ""; XBinaryCondition node; {checkStatus();}}
        :
        exp1 = row_value_constructor_1 a:OVERLAPS {op = a.getText();} exp2 = row_value_constructor_2

        {node = new XBinaryCondition(); node.setExpression1(exp1);
        node.setExpression2(exp2); node.setOp(op); xnode = node;}
        ;

row_value_constructor_1 returns [XExpression exp = null]
        {checkStatus();}
        :
        exp = row_value_constructor
        ;

row_value_constructor_2 returns [XExpression exp = null]
        {checkStatus();}
        :
        exp = row_value_constructor
        ;

row_value_constructor returns [XExpression exp = null]
        {String str; XExpression tmp; {checkStatus();}}
        :
        (OPEN_PAREN SELECT)=>
        exp = row_subquery
        |
        (OPEN_PAREN row_value_constructor_elem COMMA)=>
        OPEN_PAREN tmp = row_value_const_list CLOSE_PAREN
        {exp = new XExpression();
        exp.setValue("(" + tmp.toString() +")", XExpression.EXPRESSION);}
        | exp = row_value_constructor_elem
        //| str = truth_value {exp = new XExpression(str, XExpression.EXPRESSION);}
        ;

row_subquery returns [XExpression exp = null]
        {checkStatus();}
        :
        //exp = subquery
        // I replaced "subquery" with "query_spec" to improve performance
        OPEN_PAREN
        exp = query_spec
        CLOSE_PAREN
        ;

row_value_constructor_elem returns [XExpression exp = null]
        :
        exp = value_exp
        //| b:DEFAULT {exp = new XExpression(); exp.setValue(b.getText(), XExpression.EXPRESSION);}

        {checkStatus();}
        ;

row_value_const_list returns [XExpression exp = null]
        {String str = ""; XExpression tmp; {checkStatus();}}
        :
        tmp = row_value_constructor_elem {str = tmp.toString();}
        ( COMMA tmp = row_value_constructor_elem {str += "," + tmp.toString();})*
        {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        ;

value_exp returns [XExpression exp = null]
        {String str;
        hasField = false;
        {checkStatus();}
        }
        :
        /*
        (value_exp_primary CONCATENATION_OP)=>
        str = string_value_exp {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        |
        */
        (num_value_exp)=>
        exp = num_value_exp
        |
        (string_value_exp)=>
        str = string_value_exp {exp = new XExpression();
        exp.setValue(str, XExpression.EXPRESSION);}
        |
        str = truth_value { exp = new XExpression();
        exp.setValue(str, XExpression.EXPRESSION); }
        |
        (datetime_value_exp)=>
        str = datetime_value_exp {exp = new XExpression();
        exp.setValue(str, XExpression.EXPRESSION);}
        |
        a:NULL { exp = new XExpression();
        exp.setValue(a.getText(), XExpression.EXPRESSION); }
        | str = interval_value_exp {exp = new XExpression();
        exp.setValue(str, XExpression.EXPRESSION);}
        ;

single_value_exp
        {XExpression tmp; {checkStatus();}}
        :
        tmp = value_exp SEMI
        ;

num_value_exp returns [XExpression exp = null]
        {XExpression tmp,tmp1; {checkStatus();}}
        //remove all predictions of this rules if don't use subquery_select_list
        :
        tmp = term
        (
        //(PLUS)=>
        a:PLUS  tmp1 = num_value_exp
        {exp = new XExpression();
        exp.setValue(tmp.getQuotedValue() + a.getText() + tmp1.getQuotedValue(), XExpression.EXPRESSION);}
        |
        //(MINUS)=>
        b:MINUS tmp1 = num_value_exp
        {exp = new XExpression();
        exp.setValue(tmp.getQuotedValue() + b.getText() + tmp1.getQuotedValue(), XExpression.EXPRESSION);}
        |
        c:COLON_EQU tmp1 = num_value_exp
        {exp = new XExpression();
        exp.setValue(tmp.getQuotedValue() + c.getText() + tmp1.getQuotedValue(), XExpression.EXPRESSION);}
        )?
        {if(exp == null) {exp = tmp;}}
        ;

term returns [XExpression exp = null]
        {XExpression tmp,tmp1; }
        :
        tmp = factor
        (
        (STAR)=>
        (a:STAR  tmp1 = term)
        {
           exp = new XExpression();
           exp.setValue(tmp.getQuotedValue() + a.getText() + tmp1.getQuotedValue(),
           XExpression.EXPRESSION);
        }
        |
        //(DIV)=>
        (b:DIV  tmp1 = term)
        {
           exp = new XExpression();
           exp.setValue(tmp.getQuotedValue() + b.getText() + tmp1.getQuotedValue(), XExpression.EXPRESSION);
        })?
        {if(exp == null){exp = tmp;}}
        ;

factor returns [XExpression exp = null]
        {String prefix = null; XExpression tmp; {checkStatus();}}
        :
        (a:PLUS {prefix = a.getText();}| b:MINUS {prefix = b.getText();}|
         c:DOT {
            if(uniSql != null && uniSql.getDataSource() != null &&
               uniSql.getDataSource().getDatabaseType() == JDBCDataSource.JDBC_SQLSERVER) {
            }
            else {
               prefix = c.getText();
            }
         })? tmp = num_primary
        {
           if(prefix == null) {
              exp = tmp;
           }
           else {
              exp = new XExpression();
              exp.setValue(prefix + " " + tmp.getQuotedValue(), XExpression.EXPRESSION);
           }
        }
        ;

num_primary returns [XExpression exp = null]
        {String str; }
        :
        exp = value_exp_primary
        //| str = num_value_fct {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        ;

value_exp_primary returns [XExpression exp = null]
        {String tmp; exp = new XExpression(); {checkStatus();}}
        :
        // @by vincentx, 2004-08-13
        // parse the date type: date, time and timestamp
        (SPIDENT_BRACKET)=> m:SPIDENT_BRACKET {
           if(XUtil.parseDate(m.getText()) != null) {
              exp.setValue(XUtil.parseDate(m.getText()), XExpression.VALUE);
           }
        }
        |
        // @by billh, memorize quotes in expression
        (SPIDENT)=> s:SPIDENT {
           tmp = s.getText();
           exp.setQuote(XExpression.QUOTE_DOUBLE);
           exp.setValue(tmp.substring(1, tmp.length() - 1), XExpression.FIELD);
           columns.add(tmp.substring(1, tmp.length() - 1));
           hasField = true;
        }
        |
        (SPIDENT2)=> s2:SPIDENT2 {
           tmp = s2.getText();
           exp.setQuote(XExpression.QUOTE_SINGLE);
           exp.setValue(tmp.substring(1, tmp.length() - 1), XExpression.FIELD);
           columns.add(tmp.substring(1, tmp.length() - 1));
           hasField = true;
        }
        | tmp = unsigned_value_spec {exp.setValue(tmp,XExpression.VALUE);}
        | (OPEN_PAREN SELECT )=> exp = scalar_subquery
        | (field_exp) => tmp = field_exp {exp.setValue(tmp, XExpression.EXPRESSION);}
        | (function_name OPEN_PAREN)=> tmp = set_fct_spec {exp.setValue(tmp,XExpression.EXPRESSION);}
        | (T_DATE DATE | DATE)=> (T_DATE)? a:DATE {exp.setValue(a.getText(),XExpression.EXPRESSION);}
        | (T_TIME TIME | TIME)=> (T_TIME)? b:TIME {exp.setValue(b.getText(),XExpression.EXPRESSION);}
        | tmp = column_ref
        {
           if(tmp.startsWith("$(")){
              exp.setValue(tmp, XExpression.EXPRESSION);
           }
           else {
              exp.setValue(tmp, XExpression.FIELD);
              columns.add(tmp);
              hasField = true;
           }
        }
        | tmp = case_exp {exp.setValue(tmp,XExpression.EXPRESSION);}
        | OPEN_PAREN exp = value_exp CLOSE_PAREN
        {exp.setValue("(" + exp.toString() + ")", XExpression.EXPRESSION);}
        | tmp = cast_spec {exp.setValue(tmp,XExpression.EXPRESSION);}
        ;
field_exp returns [String value=""]
	:
	a:FIELD b:SPIDENT_SQUARE
	{
	   value = a.getText() + b.getText();
	}
	;

unsigned_value_spec returns [String uvalue = ""]
        {checkStatus();}
        :
        uvalue = unsigned_lit
        | uvalue = general_value_spec
        ;

unsigned_lit returns [String ulit = ""]
        {checkStatus();}
        :
        ulit = unsigned_num_lit
        | ulit = general_lit
        ;

unsigned_num_lit returns [String unumlit = ""]
        {checkStatus();}
        :
        a:UNSIGNED_NUM_LIT {unumlit = a.getText();}
        ;

approximate_num_lit returns [String appnumlit = ""]
        {checkStatus();}
        :
        a:APPROXIMATE_NUM {appnumlit = a.getText();}
        ;

signed_integer returns [String sint = ""]
        {String tmp; {checkStatus();}}
        :
        (a:PLUS {sint += a.getText();}
        |b:MINUS {sint += b.getText();})? tmp = unsigned_integer  {sint += tmp;}
        ;

exact_num_lit returns [String extnumlit = ""]
        {String tmp = ""; {checkStatus();}}
        :
        extnumlit = unsigned_integer ( DOT (tmp = unsigned_integer )? {extnumlit += "." + tmp;})?
        | DOT tmp = unsigned_integer {extnumlit = "." + tmp;}
        ;

general_lit returns [String glit = ""]
        {checkStatus();}
        :
        glit = char_string_lit
        //| national_char_string_lit
        //| bit_string_lit
        //| hex_string_lit
        //| datetime_lit
        | glit = interval_lit
        ;

interval_lit returns [String intv = ""]
        {String tmp = "", tmp1; {checkStatus();}}
        :
        a:INTERVAL {intv = a.getText();}
        ( b:PLUS {intv += " " + b.getText();}| c:MINUS {intv += " " + c.getText();})?
        ( tmp = interval_string | d:UNSIGNED_NUM_LIT { tmp = d.getText(); })
        tmp1 = interval_qualifier
        {intv += " " + tmp + " " + tmp1;}
        ;

interval_string returns [String intstr = ""]
        {String tmp; {checkStatus();}}
        :
        a:STRING_LITERAL {intstr = a.getText();}
        /*
        ( SINGLE_QUOTE
        ( (year_month_literal)=> tmp = year_month_literal | tmp = day_time_literal )
        SINGLE_QUOTE )
        {intstr = "'" + tmp + "'";} */
        ;

year_month_literal returns [String yml = ""]
        {String tmp; {checkStatus();}}
        :
        (years_value MINUS)=>
         yml = years_value MINUS tmp = months_value {yml += " - " + tmp; }
         | yml = years_value
        ;

years_value returns [String yv = ""]
        {checkStatus();}
        :
        yv = unsigned_integer
        ;

months_value returns [String mv = ""]
        {checkStatus();}
        :
        mv = unsigned_integer
        ;

day_time_literal returns [String dtl = ""]
        {checkStatus();}
        :
        (day_time_interval)=>
        dtl = day_time_interval
        | dtl = time_interval
        ;

day_time_interval returns [String dti = ""]
        {String tmp; {checkStatus();}}
        :
        dti = days_value
        ( tmp = hours_value {dti += " " + tmp;}
                ( a:COLON tmp = minutes_value {dti += a.getText() + tmp;}
                        ( b:COLON tmp = seconds_value {dti += b.getText() + tmp;})?
                )?
        )?
        ;

time_interval returns [String ti = ""]
        {String tmp; {checkStatus();}}
        :
        (hours_value ( COLON minutes_value ( COLON seconds_value )? )?)=>
        ti = hours_value
        ( a:COLON tmp = minutes_value {ti += a.getText() + tmp;}
                ( b:COLON tmp = seconds_value {ti += b.getText() + tmp;})?
        )?
        |
        ( minutes_value ( COLON seconds_value )? )=>
        ti = minutes_value ( c:COLON tmp = seconds_value {ti += c.getText() + tmp;})?
        | ti = seconds_value
        ;

days_value returns [String dv = ""]
        {checkStatus();}
        :
        dv = unsigned_integer
        ;

hours_value returns [String hv = ""]
        {checkStatus();}
        :
        hv = unsigned_integer
        ;

minutes_value returns [String mv = ""]
        {checkStatus();}
        :
        mv = unsigned_integer
        ;

seconds_fraction returns [String sf = ""]
        {checkStatus();}
        :
        sf = unsigned_integer
        ;

seconds_integer_value returns [String siv = ""]
        {checkStatus();}
        :
        siv = unsigned_integer
        ;

seconds_value returns [String sv = ""]
        {String tmp; {checkStatus();}}
        :
        sv = seconds_integer_value
        ( DOT {sv += ".";}( tmp = seconds_fraction {sv += tmp;})? )? ;

char_string_lit returns [String cslit = ""]
        {String tmp = "", tmp1 = ""; {checkStatus();}}
        :
        (tmp = introducer tmp1 = char_set_spec )?
        a:STRING_LITERAL {
       cslit = tmp1 + a.getText();
       if(tmp.length() > 0) { cslit = tmp + " " + cslit; }
    }
        ;

introducer returns [String intrd = ""]
        {checkStatus();}
        :
        a:INTRODUCER {intrd = a.getText();}
        ;

char_set_spec returns [String charset = ""]
        {checkStatus();}
        :
        charset = char_set_name
        ;

char_set_name returns [String charsetname = ""]
        {String tmp; {checkStatus();}}
        :
        ((schema_identifier DOT)=> tmp = schema_identifier DOT {charsetname = tmp + ".";})?
        tmp = sql_language_id {charsetname += tmp;}
        ;

sql_language_id returns [String sqllangid = ""]
        {checkStatus();}
        :
        a:IDENT {sqllangid = a.getText();}
        |sqllangid = special_identifier
        ;

general_value_spec returns [String gvalue = ""]
        {checkStatus();}
        :
        (parameter_spec)=>
        gvalue = parameter_spec
        | gvalue = dyn_parameter_spec
        | gvalue = variable_spec
        ;

parameter_spec returns [String para = ""]
        {String tmp; {checkStatus();}}
        :
        para = parameter_name (tmp = indicator_parameter {para +=" " + tmp;})?
        ;

parameter_name returns [String paraname = ""]
        {String tmp = ""; {checkStatus();}}
        :
        COLON (a:IDENT {paraname = ":" + a.getText();}
        | tmp = special_identifier {paraname = ":" + tmp;})
        ;

indicator_parameter returns [String indipara = ""]
        {String tmp; {checkStatus();}}
        :
        ( a:INDICATOR {indipara = a.getText();})? tmp = parameter_name
        {indipara += tmp;}
        ;

dyn_parameter_spec returns [String dynp = ""]
        {checkStatus();}
        :
        a:QUESTION_MARK {dynp = a.getText();}
        ;

variable_spec returns [String varspec = ""]
        {String tmp; {checkStatus();}}
        :
        varspec = embdd_variable_name (tmp = indicator_variable {varspec += " " + tmp;})?
        ;

embdd_variable_name returns [String embedvname = ""]
        {String tmp = ""; {checkStatus();}}
        :
        COLON (a:IDENT {embedvname = ":" + a.getText();}
        | tmp = special_identifier {embedvname = ":" + tmp;})
        ;

indicator_variable returns [String indivar = ""]
        {String tmp; {checkStatus();}}
        :
        ( a:INDICATOR {indivar = a.getText();})? tmp = embdd_variable_name {indivar += tmp;}
        ;

column_ref returns [String colref = ""]
        {String tmp; }
        :
        // "order" and "simple" might be used as a table name
        a:ORDER DOT tmp = column_name {colref = a.getText() + "." + quoteDot(tmp);}
        |
        b:SIMPLE DOT tmp = column_name {colref = b.getText() + "." + quoteDot(tmp);}
        |
        colref = table_name (DOT tmp = column_name {colref += "." + quoteDot(tmp);})?
        ;

set_fct_spec returns [String setfct = ""]
        {checkStatus();}
        :
        //(COUNT OPEN_PAREN STAR )=>
        //COUNT OPEN_PAREN STAR CLOSE_PAREN {setfct = "count(*)";}
        //|
        setfct = function
        //| setfct = general_set_fct
        ;
/*
general_set_fct returns [String gensetfct = ""]
        {String tmp = ""; XExpression exp, exp1; {checkStatus();}}
        :
        (gensetfct = set_fct_type
        OPEN_PAREN tmp = set_quantifier exp = value_exp CLOSE_PAREN
        {gensetfct += "(" + tmp + " " + exp.toString() + ")";})
        |(a:MOD OPEN_PAREN exp = value_exp COMMA exp1 = value_exp CLOSE_PAREN
        {gensetfct = a.getText() + "(" + exp.toString() + "," + exp1.toString() + ")";})
        ;

set_fct_type returns [String setfcttype = ""]
        {checkStatus();}
        :
        a:IDENT {setfcttype = a.getText();}
        | b:COUNT {setfcttype = b.getText();}
        ;
*/
function returns [String func = ""]
        {String tmp = ""; String distinct = ""; String str; XExpression exp; XFilterNode tnode; {checkStatus();}}
        :
        func = function_name OPEN_PAREN
        (
         (
         ((DISTINCT)? value_exp (COMMA|CLOSE_PAREN))=>
         (DISTINCT {distinct = "distinct ";})? exp = value_exp {tmp = distinct + exp.getQuotedValue();}
         |
         (boolean_term (COMMA|CLOSE_PAREN))=>
         tnode = boolean_term {tmp = tnode.toString();}
         |
         STAR {tmp = "*";}
         )
         ( COMMA
          (
          (value_exp (COMMA|CLOSE_PAREN))=>
          exp = value_exp {tmp += "," + exp.getQuotedValue();}
          |
          (boolean_term (COMMA|CLOSE_PARENT))=>
          tnode = boolean_term {tmp += "," + tnode.toString();}
          )
         )*
        )? CLOSE_PAREN
        {func += "(" + tmp + ")";}
        (
        OVER
        OPEN_PAREN tmp = analytic_clause CLOSE_PAREN
        {func += " over (" + tmp + ")";})?
        ;

analytic_clause returns [String ret = ""]
        {String tmp; {checkStatus();}}
        :
        (ret = query_partition_clause)?
        (tmp = order_by_clause[null] {ret += " " + tmp;})?
        ;

query_partition_clause returns [String ret = ""]
        {XExpression exp = null; {checkStatus();}}
        :
        PARTITION BY
        exp = value_exp {ret = " partition by " + exp.toString();}
        (COMMA exp = value_exp {ret += ", " + exp.toString();})*
        ;

function_name returns [String fn = ""]
        {checkStatus();}
        :
        a:IDENT {fn = a.getText();}
        |
        b:T_DATE {fn = b.getText();}

        // @by billh, here do not support function like a.trim(str) to avoid
        // too many exceptions in antlr which is an overhead. I prefer an angile
        // failed parse process to an unwieldy successful parse process
        //(DOT b:IDENT { fn += "." + b.getText(); } )*
        ;

scalar_subquery returns [XExpression subsql = null]
        {checkStatus();}
        :
        //subsql = subquery
        // I replaced "subquery" with "query_spec" to improve performance
        OPEN_PAREN
        subsql = query_spec
        CLOSE_PAREN
        ;

case_exp returns [String caseexp = ""]
        {checkStatus();}
        :
        caseexp = case_abbreviation
        | caseexp = case_spec
        ;

case_abbreviation returns [String cassadd = ""]
        {XExpression exp1, exp2; {checkStatus();}}
        :
        a:NULLIF OPEN_PAREN exp1 = value_exp COMMA exp2 = value_exp CLOSE_PAREN
        {cassadd = a.getText() + "(" + exp1.toString() + "," + exp2.toString() + ")";}
        | b:COALESCE OPEN_PAREN exp1 = value_exp {cassadd = b.getText() + "(" + exp1.toString();}
        ( COMMA exp2 = value_exp {cassadd += "," + exp2.toString();})* CLOSE_PAREN
        {cassadd += ")";}
        ;

case_spec returns [String casespec = ""]
        {checkStatus();}
        :
        (CASE WHEN)=>
        casespec = searched_case
        |
        casespec = simple_case
        ;

simple_case returns [String simpcase = ""]
        {String tmp; {checkStatus();}}
        :
        a:CASE tmp = case_operand {simpcase = a.getText() + " " + tmp;}
        (tmp = simple_when_clause {simpcase += " " + tmp;})+
        {changeType("end", END) || true}?
        ( tmp = m_else_clause {simpcase += " " + tmp;})?
        {changeType("end", END)}?
        (b:END|"end") {simpcase += " END" ;}
        ;

case_operand returns [String caseop = null]
        {XExpression exp; {checkStatus();}}
        :
        exp = value_exp {caseop = exp.toString();}
        ;

simple_when_clause returns [String simpwhen = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        a:WHEN tmp = when_operand b:THEN tmp1 = result
        {simpwhen = a.getText() + " " + tmp + " " + b.getText() + " " + tmp1;}
        ;

when_operand returns [String whenop = ""]
        {XExpression tmp; {checkStatus();}}
        :
        tmp = value_exp {whenop += tmp.toString();}
        ;

result returns [String ret = ""]
        {checkStatus();}
        :
        ret = result_exp
        ;

result_exp returns [String retexp = ""]
        {XExpression tmp; {checkStatus();}}
        :
        tmp = value_exp {retexp = tmp.toString();}
        ;

m_else_clause returns [String elsestr = ""]
        {String tmp; {checkStatus();}}
        :
        a:ELSE tmp = result {elsestr = a.getText() + " " + tmp;}
        ;

searched_case returns [String searchcase = ""]
        {String tmp; tmp = ""; {checkStatus();}}
        :
        a:CASE
        tmp = searched_when_clause {searchcase = a.getText() + " " + tmp;}
        ( tmp = searched_when_clause {searchcase += " " + tmp;})*
        {changeType("end", END) || true}?
        ( tmp = m_else_clause {searchcase += " " + tmp;})?
        {changeType("end", END)}?
        (b:END|"end") {searchcase += " " + "END";}

        ;

searched_when_clause returns [String searchwhen = ""]
        {String tmp,tmp1; XFilterNode node; {checkStatus();}}
        :
        a:WHEN node = search_condition b:THEN tmp1 = result
        {SQLHelper helper = SQLHelper.getSQLHelper(this.uniSql);
         String condition = helper.generateConditions(node);
        searchwhen = a.getText() + " " + condition + " " + b.getText() + " " + tmp1;}
        ;

cast_spec returns [String cast = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        a:CAST OPEN_PAREN tmp = cast_operand b:AS tmp1 = cast_target CLOSE_PAREN
        {cast = a.getText() + "(" + tmp + " " + b.getText() + " " + tmp1 + ")";}
        ;

cast_operand returns [String caseop = ""]
        {XExpression tmp; {checkStatus();}}
        :
        tmp = value_exp {caseop = tmp.toString();}
        ;

cast_target returns [String casttar = ""]
        {checkStatus();}
        :
        (data_type)=>
        casttar = data_type
        |  casttar = domain_name
        ;

domain_name returns [String domainname = ""]
        {checkStatus();}
        :
        domainname = qualified_name
        ;

schema_name returns [String schemaname = ""]
        {checkStatus();}
        :
        a:IDENT {schemaname = a.getText();}
        | schemaname = special_identifier
        ;

qualified_id returns [String qid = ""]
        :
        (a:IDENT {qid = a.getText();}
        | qid = special_identifier
        | b:T_TIME {qid = b.getText();}
        | c:T_DATE {qid = c.getText();})
        ;

data_type returns [String datatype = ""]
        {String tmp; {checkStatus();}}
        :
        (national_char_string_type)=> datatype = national_char_string_type
        //( a:CHARACTER b:SET tmp = char_set_spec
        //{datatype += a.getText() + " " + b.getText() + " " + tmp;})?
        | (num_type)=> datatype = num_type
        | datatype = datetime_type
        | datatype = interval_type
        ;

length returns [String len = ""]
        {checkStatus();}
        :
        len = unsigned_integer
        ;

unsigned_integer returns [String uint = ""]
        {checkStatus();}
        :
        //DIGIT ( DIGIT )*
        a:UNSIGNED_NUM_LIT {uint = a.getText();}
        ;

national_char_string_type returns [String ncs = ""]
        {String tmp; {checkStatus();}}
        :
        a:IDENT {ncs = a.getText();}(b:IDENT {ncs += " " + b.getText();})*
        ( OPEN_PAREN tmp = length CLOSE_PAREN {ncs += "(" + tmp + ")";})?
        ;

num_type returns [String nt = ""]
        {checkStatus();}
        :
        nt = exact_num_type
        ;

exact_num_type returns [String ent = ""]
        {String tmp,tmp1; {checkStatus();}}
        :
        a:IDENT {ent = a.getText();}
        ( OPEN_PAREN tmp = precision {ent += "(" + tmp;}
        ( COMMA tmp1 = scale {ent += ","+tmp1;})? CLOSE_PAREN {ent += ")";})?
        ;

precision returns [String pre = ""]
        {checkStatus();}
        :
        pre = unsigned_integer
        ;

scale returns [String sca = ""]
        {checkStatus();}
        :
        sca = unsigned_integer
        ;


datetime_type returns [String datetype = ""]
        {String tmp; {checkStatus();}}
        :
        a:IDENT {datetype = a.getText();}
        ( OPEN_PAREN tmp = time_precision CLOSE_PAREN {datetype += "(" + tmp + ")";})?
        ( c:IDENT d:IDENT e:IDENT {datetype += c.getText() + d.getText() + e.getText();})?
        ;

time_precision returns [String tp = ""]
        {checkStatus();}
        :
        tp = time_frac_seconds_prec
        ;

time_frac_seconds_prec returns [String tfsp = ""]
        {checkStatus();}
        :
        tfsp = unsigned_integer
        ;

interval_type returns [String it = ""]
        {String tmp; {checkStatus();}}
        :
        a:INTERVAL tmp = interval_qualifier {it = a.getText() + tmp;}
        ;

interval_qualifier returns [String iq = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        // To remove TO keyword
        //(start_field TO)=>
        //tmp = start_field a:TO tmp1 = end_field {iq = tmp + " " + a.getText() + " " + tmp1;}
        //|
        iq = single_datetime_field
        ;

start_field returns [String sf = ""]
        {String tmp; {checkStatus();}}
        :
        sf = non_second_datetime_field
        ( OPEN_PAREN tmp = interval_leading_fieldprec CLOSE_PAREN {sf += "(" + tmp +")";})?
        ;

non_second_datetime_field returns [String nsdf = ""]
        {checkStatus();}
        :
        a:IDENT {nsdf = a.getText();}
        ;

interval_leading_fieldprec returns [String ilf = ""]
        {checkStatus();}
        :
        ilf = unsigned_integer
        ;

end_field returns [String ef = ""]
        {String tmp; {checkStatus();}}
        :
        ef = non_second_datetime_field
        | a:SECOND {ef = a.getText();}
        ( (OPEN_PAREN interval_frac_seconds_prec)=>
        OPEN_PAREN tmp = interval_frac_seconds_prec CLOSE_PAREN {ef += "(" + tmp +")";})?
        ;

interval_frac_seconds_prec returns [String ifsp = ""]
        {checkStatus();}
        :
        ifsp = unsigned_integer
        ;

single_datetime_field returns [String sdf = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        sdf = non_second_datetime_field
        ( (OPEN_PAREN interval_leading_fieldprec)=>
        OPEN_PAREN tmp = interval_leading_fieldprec CLOSE_PAREN {sdf += "(" + tmp +")";})?
        | a:SECOND {sdf += a.getText();}
        ( (OPEN_PAREN interval_leading_fieldprec)=>
        OPEN_PAREN tmp = interval_leading_fieldprec {sdf += "(" + tmp;}
        ( COMMA tmp1 = interval_frac_seconds_prec {sdf += "," + tmp1;})? CLOSE_PAREN
        {sdf += ")";})?
        ;

/*
num_value_fct returns [String nvf = ""]
        {checkStatus();}
        :
        nvf = position_exp
        | nvf = extract_exp
        | nvf = length_exp
        ;
*/

/*
position_exp returns [String pe = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        a:POSITION OPEN_PAREN tmp = char_value_exp
        b:IN tmp1 = char_value_exp CLOSE_PAREN
        {pe = a.getText() + "(" + tmp + " " + b.getText() + " " + tmp1 + "(";}
        ;
*/

char_value_exp returns [String cve = ""]
        {XExpression exp1, exp2; checkStatus();}
        :
        // @by billh, here prediction is too heavy and occupies too much time,
        // we use star to eliminate prediction
        /*
        (char_factor CONCATENATION_OP)=>
        cve = concatenation
        | cve = char_factor
        ;
        */
        exp1 = char_factor {cve += exp1.getQuotedValue();} (a:CONCATENATION_OP exp2 = char_factor {cve += " " + a.getText() + " " + exp2.getQuotedValue();})*
        ;
/*
concatenation returns [String concatent = ""]
        {XExpression tmp, tmp1; {checkStatus();}}
        :
        tmp = char_factor a:CONCATENATION_OP tmp1 = char_value_exp
        {concatent = tmp.getQuotedValue() + " " + a.getText() + " " + tmp1.getQuotedValue();}
        ;
*/
char_factor returns [XExpression exp = null]
        {String tmp; {checkStatus();}}
        :
        exp = char_primary //((collate_clause)=> tmp = collate_clause {cf += tmp;})?
        ;

char_primary returns [XExpression exp = null]
        {{checkStatus();}}
        :
        exp = value_exp_primary
        //| cp = string_value_fct
        ;

string_value_fct returns [String svf = ""]
        {checkStatus();}
        :
        (char_value_fct)=>
        svf = char_value_fct
        | svf = bit_value_fct
        ;

char_value_fct returns [String cvf = ""]
        {checkStatus();}
        :
        cvf = char_substring_fct
        | cvf = fold
        | cvf = form_conversion
        | cvf = char_translation
        | cvf = trim_fct
        ;

char_substring_fct returns [String csf = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        a:SUBSTRING OPEN_PAREN tmp = char_value_exp b:FROM tmp1 = start_position
        {csf = a.getText() + "(" + tmp + " " + b.getText() + " " + tmp1;}
        ( c:FOR tmp = string_length {csf += " " + c.getText() + " " + tmp;})? CLOSE_PAREN
        {csf += ")";}
        ;

start_position returns [String sp = ""]
        {XExpression exp; {checkStatus();}}
        :
        exp = num_value_exp {sp = exp.toString();}
        ;

string_length returns [String sl = ""]
        {XExpression exp; {checkStatus();}}
        :
        exp = num_value_exp {sl = exp.toString();}
        ;

fold returns [String fold = ""]
        {String tmp; {checkStatus();}}
        :
        ( a:UPPER {fold = a.getText();}| b:LOWER {fold = b.getText();})
        OPEN_PAREN tmp = char_value_exp CLOSE_PAREN {fold += "(" + tmp + ")";}
        ;

form_conversion returns [String fc = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        a:CONVERT OPEN_PAREN tmp = char_value_exp b:USING tmp1 = form_conversion_name CLOSE_PAREN
        {fc = a.getText() + "(" + tmp + " " + b.getText() + " " + tmp1 + ")";}
        ;

form_conversion_name returns [String fcn = ""]
        {checkStatus();}
        :
        fcn = qualified_name
        ;

char_translation returns [String chartrans = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        a:TRANSLATE OPEN_PAREN tmp = char_value_exp b:USING tmp1=translation_name CLOSE_PAREN
        {chartrans = a.getText() + "(" + tmp + " " + b.getText() + " " + tmp1 + ")";}
        ;

translation_name returns [String transname = ""]
        {checkStatus();}
        :
        transname = qualified_name
        ;

trim_fct returns [String trimfct = ""]
        {String tmp = "", fct = ""; {checkStatus();}}
        :
        (a:TRIM {fct = a.getText();}|b:RTRIM {fct = b.getText();}|c:LTRIM {fct = c.getText();})
        OPEN_PAREN tmp = trim_operands CLOSE_PAREN
        {trimfct = fct + "(" + tmp + ")";}
        ;

trim_operands returns [String trimop = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        (trim_spec trim_char FROM)=>
        trimop = trim_spec tmp = trim_char a:FROM  tmp1 = trim_source
        {trimop += " " + tmp + " " + a.getText() + " " + tmp1;}
        |
        (trim_spec FROM)=>
        tmp = trim_spec b:FROM tmp1 = trim_source
        {trimop = tmp + " " + b.getText() + " " + tmp1;}
        |
        (trim_char FROM)=>
        tmp = trim_char c:FROM tmp1 = trim_source
        {trimop = tmp + " " + c.getText() + " " + tmp1;}
        | d:FROM tmp = trim_source {trimop = d.getText() + " " + tmp;}
        | trimop = trim_source
        ;

trim_spec returns [String trimspec = ""]
        {checkStatus();}
        :
        a:LEADING {trimspec = a.getText();}
        | b:TRAILING {trimspec = b.getText();}
        | c:BOTH {trimspec = c.getText();}
        ;

trim_char returns [String trimchar = ""]
        {checkStatus();}
        :
        trimchar = char_value_exp
        ;

trim_source returns [String trimsource = ""]
        {checkStatus();}
        :
        trimsource = char_value_exp
        ;

bit_value_fct returns [String bvf = ""]
        {checkStatus();}
        :
        bvf = bit_substring_fct
        ;

bit_substring_fct returns [String bsf = ""]
        {String tmp, tmp1, tmp2; {checkStatus();}}
        :
        a:SUBSTRING OPEN_PAREN tmp = bit_value_exp b:FROM tmp1 = start_position
        {bsf = a.getText() + "(" + tmp + " " + b.getText() + " " + tmp1;}
        ( c:FOR tmp2 = string_length {bsf += " " + c.getText() + " " + tmp2;})? CLOSE_PAREN
        {bsf += ")";}
        ;

bit_value_exp returns [String bve = ""]
        {checkStatus();}
        :
        (bit_concatenation)=>
        bve = bit_concatenation
        | bve = bit_factor
        ;

bit_concatenation returns [String bitcon = ""]
        {String tmp; {checkStatus();}}
        :
        bitcon = bit_factor a:CONCATENATION_OP  tmp = bit_value_exp
        {bitcon += " " + a.getText() + " " + tmp;}
        ;

/*
collate_clause returns [String coll = ""]
        {String tmp; {checkStatus();}}
        :
        a:COLLATE tmp = collation_name {coll = a.getText() + " " + tmp;}
        ;
*/

collation_name returns [String collname = ""]
        {checkStatus();}
        :
        collname = qualified_name
        ;

bit_factor returns [String bitfactor = ""]
        {checkStatus(); {checkStatus();}}
        :
        bitfactor = bit_primary
        ;

bit_primary returns [String bitpri = ""]
        {XExpression exp; {checkStatus();}}
        :
        (value_exp_primary)=>
        exp = value_exp_primary {bitpri = exp.toString();}
        | bitpri = string_value_fct
        ;

/*
extract_exp returns [String extexp = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        a:EXTRACT OPEN_PAREN tmp = extract_field b:FROM tmp1 = extract_source CLOSE_PAREN
        {extexp = a.getText() + "(" + tmp + " " + b.getText() + " " + tmp1 + ")";}
        ;


extract_field returns [String extfield = ""]
        {checkStatus();}
        :
        extfield = datetime_field
        | extfield = time_zone_field
        ;

datetime_field returns [String dtfield = ""]
        {checkStatus();}
        :
        dtfield = non_second_datetime_field
        | a:SECOND {dtfield = a.getText();}
        ;

time_zone_field returns [String tzf = ""]
        {checkStatus();}
        :
        a:TIMEZONE_HOUR {tzf = a.getText();}
        | b:TIMEZONE_MINUTE {tzf = b.getText();}
        ;

extract_source returns [String extsou = ""]
        {checkStatus();}
        :
        (datetime_value_exp)=>
        extsou = datetime_value_exp
        | extsou = interval_value_exp
        ;
*/

datetime_value_exp returns [String dve = ""]
        {String tmp, tmp1; {checkStatus();}}
        :
        (interval_value_exp PLUS)=>
        tmp = interval_value_exp a:PLUS tmp1 = datetime_term {dve = tmp + a.getText() + tmp1;}
        |
        (interval_term PLUS)=>
        tmp = interval_term b:PLUS tmp1 = datetime_value_exp {dve = tmp + b.getText() + tmp1;}
        |
        (interval_term MINUS )=>
        tmp = interval_term c:MINUS tmp1 = datetime_value_exp {dve = tmp + c.getText() + tmp1;}
        | dve = datetime_term
        ;

datetime_term returns [String dtterm = ""]
        {checkStatus();}
        :
        dtterm = datetime_factor
        ;

datetime_factor returns [String dtfactor = ""]
        {String tmp; {checkStatus();}}
        :
        dtfactor = datetime_primary //( tmp = time_zone {dtfactor += " " + tmp;})?
        ;

datetime_primary returns [String dtpri = ""]
        {XExpression exp; {checkStatus();}}
        :
        exp = value_exp_primary {dtpri = exp.toString();}
        //| dtpri = datetime_value_fct
        ;

/*
datetime_value_fct returns [String dtvf = ""]
        {checkStatus();}
        :
        dtvf = current_date_value_fct
        | dtvf = current_time_value_fct
        | dtvf = currenttimestamp_value_fct
        ;


current_date_value_fct returns [String cdv = ""]
        {checkStatus();}
        :
        a:CURRENT_DATE  {cdv = a.getText();}
        ;


current_time_value_fct returns [String ctvf = ""]
        {String tmp; {checkStatus();}}
        :
        a:CURRENT_TIME {ctvf = a.getText();}
        ( (OPEN_PAREN time_precision CLOSE_PAREN)=>
        OPEN_PAREN tmp = time_precision CLOSE_PAREN {ctvf += "(" + tmp + ")";})?
        ;


currenttimestamp_value_fct returns [String cvf = ""]
        {String tmp; {checkStatus();}}
        :
        a:CURRENT_TIMESTAMP {cvf = a.getText();}

        ( (OPEN_PAREN timestamp_precision CLOSE_PAREN)=>
        OPEN_PAREN tmp = timestamp_precision CLOSE_PAREN {cvf += "(" + tmp + ")";})?
        ;


timestamp_precision returns [String tp = ""]
        {checkStatus();}
        :
        tp = time_frac_seconds_prec
        ;


time_zone returns [String tz = ""]
        {String tmp; {checkStatus();}}
        :
        a:AT tmp = time_zone_specifier {tz = a.getText() + " " + tmp;}
        ;


time_zone_specifier returns [String tzs = ""]
        {String tmp; {checkStatus();}}
        :
        a:LOCAL {tzs = a.getText();}
        | b:T_TIME c:ZONE tmp = interval_value_exp
        {tzs = b.getText() + " " + c.getText() + " " + tmp;}
        ;
*/

interval_value_exp returns [String ive = ""]
        {String tmp, tmp1, tmp2; {checkStatus();}}
        :
        (interval_term_1 PLUS )=>
        tmp = interval_term_1 a:PLUS  tmp1 = interval_value_exp_1
        {ive = tmp + a.getText() + tmp1;}
        |
        (interval_term_1 MINUS )=>
        tmp = interval_term_1 b:MINUS  tmp1 = interval_value_exp_1
        {ive = tmp + b.getText() + tmp1;}
        |
        (OPEN_PAREN datetime_value_exp)=>
        OPEN_PAREN tmp = datetime_value_exp c:MINUS tmp1 = datetime_term CLOSE_PAREN tmp2 = interval_qualifier
        {ive = "(" + tmp + c.getText() + tmp1 + ") " + tmp2;}
        | ive = interval_term
        ;

interval_term returns [String it = ""]
        {String tmp1; XExpression exp; {checkStatus();}}
        :
        (factor STAR ) =>
        exp = factor a:STAR tmp1 = interval_term_2 {it = exp.toString() + a.getText() + tmp1;}
        |
        (factor DIV )=>
        exp = factor b:DIV tmp1 = interval_term_2 {it = exp.toString() + b.getText() + tmp1;}
        |
        (term STAR)=>
        exp = term c:STAR tmp1 = interval_factor {it = exp.toString() + c.getText() + tmp1;}
        | it = interval_factor
        ;

interval_factor returns [String ifact = ""]
        {String tmp; {checkStatus();}}
        :
        ( a:STAR {ifact = a.getText();}| b:DIV {ifact = b.getText();} )? tmp = interval_primary
        {ifact += " " + tmp;}
        ;

interval_primary returns [String ip = ""]
        {String tmp; XExpression exp; {checkStatus();}}
        :
        exp = value_exp_primary {ip = exp.toString();}
        ((interval_qualifier)=> tmp = interval_qualifier {ip += " " + tmp;})?
        ;

interval_term_2 returns [String it2 = ""]
        {checkStatus();}
        :
        it2 = interval_term
        ;

interval_term_1 returns [String it1 = ""]
        {checkStatus();}
        :
        it1 = interval_term
        ;

interval_value_exp_1 returns [String ive1 = ""]
        {checkStatus();}
        :
        ive1 = interval_value_exp
        ;

/*length_exp returns [String le = ""]
        {checkStatus();}
        :
        le = char_length_exp
        | le = octet_length_exp
        | le = bit_length_exp
        ;
*/

/*
char_length_exp returns [String cle = ""]
        {String tmp; {checkStatus();}}
        :
        ( (CHAR_LENGTH)=> a:CHAR_LENGTH {cle = a.getText();}| b:CHARACTER_LENGTH {cle = b.getText();})
        OPEN_PAREN tmp = string_value_exp CLOSE_PAREN {cle += "(" + tmp + ")";}
        ;
*/

string_value_exp returns [String sve = ""]
        {checkStatus();}
        :
        (char_value_exp)=>
        sve = char_value_exp
        | sve = bit_value_exp
        ;

/*
octet_length_exp returns [String ole = ""]
        {String tmp; {checkStatus();}}
        :
        a:OCTET_LENGTH OPEN_PAREN tmp = string_value_exp CLOSE_PAREN
        {ole = a.getText() + "(" + tmp + ")";}
        ;

bit_length_exp returns [String ble = ""]
        {String tmp; {checkStatus();}}
        :
        a:BIT_LENGTH OPEN_PAREN tmp = string_value_exp CLOSE_PAREN
        {ble = a.getText() + "(" + tmp + ")";}
        ;
*/

subquery returns [XExpression exp = null]
        {checkStatus();}
        :
        OPEN_PAREN exp = query_exp CLOSE_PAREN
        ;

query_exp returns [XExpression exp = null]
        {checkStatus();}
        :
        (joined_table)=>
        exp = joined_table
        | exp = non_join_query_exp
        ;

non_join_query_exp returns [XExpression exp = null]
        {XExpression tmp; String str = "", str1; {checkStatus();}}
        :
        (query_term (UNION|EXCEPT|MINUS_STR))=>
        (
        tmp=query_term
        (
          //(UNION)=>
          a:UNION {str = tmp.toString() + " " + a.getText();}
          ( b:ALL {str += " " + b.getText();})?
          ( str1 = corresponding_spec {str += " " + str1;})?
          tmp = query_exp
          {str += " " + tmp.toString();exp = new XExpression();exp.setValue(str,XExpression.EXPRESSION);}
          | //(EXCEPT)=>
          c:EXCEPT {str = tmp.toString() + " " + c.getText();}
          ( d:ALL {str += " " + d.getText();})?
          ( str1 = corresponding_spec {str += " " + str1;})?
          tmp = query_exp
          {str += " " + tmp.toString(); exp = new XExpression(); exp.setValue(str,XExpression.EXPRESSION);}
          | //(MINUS_STR)=>
          e:MINUS_STR {str = tmp.toString() + " " + e.getText();}
          ( f:ALL {str += " " + f.getText();})?
          ( str1 = corresponding_spec {str += " " + str1;})?
          tmp = query_exp
          {str += " " + tmp.toString(); exp = new XExpression(); exp.setValue(str,XExpression.EXPRESSION);}
        )
        )
        |
        exp = non_join_query_term
        ;

non_join_query_term returns [XExpression exp = null]
        {XExpression tmp; String str = "", str1; {checkStatus();}}
        :
        (query_primary INTERSECT)=>
        tmp = query_primary a:INTERSECT {str = tmp.toString() + " " + a.getText();}
        ( b:ALL {str += " " + b.getText();})?
        ( str1 = corresponding_spec {str += " " + str1;})?
        tmp = query_term
        {str += " " + tmp.toString(); exp = new XExpression(); exp.setValue(str,XExpression.EXPRESSION);}
        |
        exp = non_join_query_primary
        ;

non_join_query_primary returns [XExpression exp = null]
        {checkStatus();}
        :
        exp = simple_table
        | OPEN_PAREN exp = non_join_query_exp CLOSE_PAREN
        ;

simple_table returns [XExpression exp = null]
        {checkStatus();}
        :
        exp = query_spec
        | exp = table_value_constructor
        | exp = explicit_table
        ;

query_spec returns [XExpression exp = null]
        {
           UniformSQL subquery = new UniformSQL();
           JDBCSelection selection = new JDBCSelection();
           String tmp;
           {checkStatus();}
        }
        :
        SELECT
        ( tmp = set_quantifier
        {if(tmp.equalsIgnoreCase("all")){
                subquery.setAll(true);
        }
        else {
                subquery.setDistinct(true);
        }})?
        (TOP UNSIGNED_NUM_LIT { uniSql.setLossy(true); } )?
        selection = select_list[subquery] table_exp[subquery]
        {subquery.setSelection(selection); exp = new XExpression(); exp.setValue(subquery,XExpression.SUBQUERY);}
        ;

/*subquery_select_list [UniformSQL sql] returns [JDBCSelection selection = new JDBCSelection()]
        {checkStatus();}
        :
        (STAR)=>
        a:STAR {selection.addColumn("*");}
        | select_sublist[selection, sql] ( (COMMA)? select_sublist[selection, sql] )*
        ;
*/

set_quantifier returns [String sq = ""]
        {checkStatus();}
        :
        a:DISTINCT {sq = a.getText();}
        | b:ALL {sq = b.getText();}
        ;

select_list [UniformSQL sql] returns [JDBCSelection selection = new JDBCSelection()]
        {checkStatus();}
        :
        (STAR)=>
        a:STAR {selection.addColumn("*");}
        | select_sublist[selection, sql] ( COMMA select_sublist[selection, sql] )*
        ;

select_sublist [JDBCSelection selection, UniformSQL sql]
        {String tmp, tmp1; {checkStatus();}}
        :
        (qualifier DOT STAR)=>
        tmp = qualifier DOT STAR {selection.addColumn(tmp + ".*");}
        |
        (table_name UNION JOIN)=>
        tmp = table_name a:UNION b:JOIN tmp1 = table_name
        {tmp += " " + a.getText() + " " + b.getText() + " " + tmp1;
        selection.addColumn(tmp);
        }
        |
        derived_column[selection, sql]

        ;

qualifier returns [String quf = ""]
        {checkStatus();}
        :
        (table_name)=>
        quf = table_name
        | quf = correlation_name
        ;

table_name returns [String tname = ""]
        :
        tname = qualified_name
        ;

qualified_name returns [String qname = ""]
        {String tmp = ""; }
        :
        ((catalog_name DOT)=> tmp = catalog_name DOT {qname += quoteDot(tmp) + ".";}
        ( (~DOT)=> tmp = schema_name DOT {qname+=quoteDot(tmp)+".";}| DOT {qname+=".";})?
        )?
        tmp = qualified_id {qname += quoteDot(tmp);}
        ;

catalog_name returns [String catname = ""]
        {checkStatus();}
        :
        catname = qualified_id
        ;

/*
qualified_local_table_name returns [String qltname = ""]
        {String tmp = ""; {checkStatus();}}
        :
        a:MODULE DOT tmp = local_table_name {qltname = a.getText() + "." + tmp;}
        ;


local_table_name returns [String ltname = ""]
        {checkStatus();}
        :
        ltname = qualified_id
        ;
*/

correlation_name returns [String corname = ""]
        {checkStatus();}
        :
        a:IDENT {corname = a.getText();}
        | corname = special_identifier
        ;

derived_column [JDBCSelection selection, UniformSQL sql]
        {String tmp = null, aliastmp = null; XExpression exp; {checkStatus();}}
        :
        (column_name EQ)=>
        aliastmp=column_name EQ exp=value_exp  // to support sybase gramma: select a=b, ....
        {tmp = exp.toString(); selection.addColumn(tmp); selection.setAlias(selection.getColumnCount() - 1,aliastmp);}
        |
        exp = value_exp
        {
           tmp = exp.toString();

           if(sql.getDataSource() != null &&
              sql.getDataSource().getDatabaseType() == JDBCDataSource.JDBC_ORACLE &&
              exp.getType().equals(XExpression.FIELD))
       {
              tmp = tmp.toUpperCase();
           }

           selection.addColumn(tmp);
        }

        (//(as_clause)=>        //remove the prediction if don't use subquery_select_list
        aliastmp = as_clause
        {
           int columnIdx = selection.getColumnCount() - 1;

           if(getDatabaseType() == JDBCDataSource.JDBC_CLICKHOUSE) {
              String column = selection.getColumn(columnIdx);
              column = column + aliastmp;
              selection.setColumn(columnIdx, column);
              selection.setAlias(columnIdx, column);
           }
           else {
              selection.setAlias(selection.getColumnCount() - 1, aliastmp);
           }
        }
        )?
        ;

as_clause returns [String as = ""]
        {checkStatus();}
        :
        (AS)?
        (as = column_name
        | a:STRING_LITERAL {as = a.getText();
          as = as.substring(1, as.length()-1);}
        | b:T_DATE { as = b.getText(); })
        ;

column_name returns [String colname = ""]
        {checkStatus();}
        :
        a:IDENT {colname = a.getText();}
        | colname = special_identifier
        | b:T_TIME {colname = b.getText();}
        ;

table_exp [UniformSQL sql]
        {XFilterNode where, having; String nouse; {checkStatus();}}
        :
        (from_clause[sql])?
        ( where = where_clause {where.setClause(XFilterNode.WHERE); sql.combineWhereByAnd(where);})?
        ( group_by_clause[sql] )?
        ( having = having_clause {having.setClause(XFilterNode.HAVING); sql.setHaving(having);})?
        ((ORDER BY)=> nouse = order_by_clause[sql] )?
        ;

from_clause [UniformSQL sql]
        {String tmp; {checkStatus();}}
        :
        FROM tmp = table_ref[sql] ( COMMA tmp = table_ref[sql] )*
        ;

ansi_joins [UniformSQL sql] returns [String str = ""]
     {String tmp, tmp2; XExpression exp; {checkStatus();}}
     :
         (table_ref_nojoin[null, null] CROSS)=>
        exp = cross_join[sql] { str = exp.toString(); }
     |
         (table_ref_nojoin[null, null] join_hint)=>
        exp = qualified_join[sql] { str = exp.toString(); }
     | OPEN_PAREN tmp = ansi_joins[sql] CLOSE_PAREN
        tmp2 = sub_qualified_join[sql] { str = "(" + tmp + ") " + tmp2;}
;

table_ref [UniformSQL sql] returns [String tbref = ""]
        {Object name; String alias = "", tmp,as = ""; XExpression exp; {checkStatus();}}
        :
     (ansi_joins[null])=> tbref = ansi_joins[sql]
        | name = derived_table
        (( b:AS {as = b.getText();})?
        alias = correlation_name

        {
           if(alias.startsWith("$(@") && alias.endsWith(")")) {
              alias = "";
           }
        }

        ( OPEN_PAREN tmp = derived_column_list CLOSE_PAREN {alias += "(" + tmp + ")";})? )?
        {
        tbref = name + " " + as + " " + alias;
        if(sql != null) {
                if(!alias.equals("")) {
                        sql.addTable(alias, name);
                }
                else {
                        sql.addTable(name);
                }
        }
        }
        |
        name = table_name
        (
         ( a:AS {as = a.getText();})?
         alias = correlation_name

         {
            if(alias.startsWith("$(@") && alias.endsWith(")")) {
              alias = "";
            }
         }

         ( OPEN_PAREN tmp = derived_column_list CLOSE_PAREN {alias += "(" + tmp + ")";})?
        )?
        {
         tbref = name + " " + as + " " + alias;

         if(sql != null) {
                 if(!alias.equals("")) {
                        sql.addTable(alias, name);
                 }
                 else {
                        sql.addTable(name);
                 }
         }
         }
        ;

table_ref_nojoin [UniformSQL sql, String op] returns [String tbref = ""]
        {Object name; String alias = "", tmp,as = ""; {checkStatus();}}
        :
        name = table_name
        (
         ( a:AS {as = a.getText();})?
         alias = correlation_name
         ( (OPEN_PAREN derived_column_list)=>
         OPEN_PAREN tmp = derived_column_list CLOSE_PAREN {alias += "(" + tmp + ")";})?
        )?
        {
         tbref = name + " " + as + " " + alias;

         if(sql != null) {
                 if(!alias.equals("")) {
                        sql.addTable(alias, name);

                        if(op != null && op.trim().length() > 0) {
                           clearTableOps();
                           setTableOp(sql, alias, op.trim());
                           setTableOp(sql, name, op.trim());
                        }
                 }
                 else {
                        sql.addTable(name);

                        if(op != null && op.trim().length() > 0) {
                           clearTableOps();
                           setTableOp(sql, name, op.trim());
                        }
                 }
         }
         }
        | name = derived_table
        ( b:AS {as = b.getText();})?
        alias = correlation_name
        ( (OPEN_PAREN derived_column_list)=>
        OPEN_PAREN tmp = derived_column_list CLOSE_PAREN {alias += "(" + tmp + ")";})?
        {
        tbref = name + " " + as + " " + alias;

        if(sql != null) {
                if(!alias.equals("")) {
                        sql.addTable(alias, name);

                        if(op != null && op.trim().length() > 0) {
                           clearTableOps();
                           setTableOp(sql, alias, op.trim());
                           setTableOp(sql, name, op.trim());
                        }
                }
                else {
                        sql.addTable(name);

                        if(op != null && op.trim().length() > 0) {
                           clearTableOps();
                           setTableOp(sql, name, op.trim());
                        }
                }
        }
        }
        ;

derived_column_list returns [String dcl = ""]
        {checkStatus();}
        :
        dcl = column_name_list[null]
        ;

column_name_list [Vector list] returns [String cnl = ""]
        {String tmp; {checkStatus();}}
        :
        cnl = column_name {if(list != null){list.addElement(cnl);}}
        ( COMMA tmp = column_name {cnl += "," + tmp;if(list != null){list.addElement(tmp);}})*
        ;

derived_table returns [Object dt = ""]
        {XExpression exp; {checkStatus();}}
        :
        exp = table_subquery
        {dt = exp.getValue();}
        ;

group_by_clause [UniformSQL sql]
        {
         Vector group = new Vector();
         Vector tmp;
         sql.setGroupByAll(false);
         {checkStatus();}
        }
        :
        GROUP BY
        (ALL {sql.setGroupByAll(true);})?
        (
        (grouping_column_ref_list)=>
        group = grouping_column_ref_list
        |(OPEN_PAREN CLOSE_PAREN)=>
        OPEN_PAREN CLOSE_PAREN
        |(grouping_set COMMA grouping_set_list)=>
        grouping_set COMMA grouping_set_list
        |ROLLUP OPEN_PAREN tmp = grouping_column_ref_list CLOSE_PAREN
        |CUBE OPEN_PAREN tmp = grouping_column_ref_list CLOSE_PAREN
        |GROUPING SETS OPEN_PAREN grouping_set_list CLOSE_PAREN
        )?
        {sql.setGroupBy(group.toArray());}
        ;

grouping_set_list
        {checkStatus();}
        :
        grouping_set (COMMA grouping_set)*
        ;

grouping_set
        {Vector tmp; String tstr; {checkStatus();}}
        :
        (OPEN_PAREN grouping_column_ref_list)=>
        OPEN_PAREN tmp = grouping_column_ref_list CLOSE_PAREN
        |
        (grouping_column_ref)=>
        tstr = grouping_column_ref
        |ROOLUP OPEN_PAREN tmp = grouping_column_ref_list CLOSE_PAREN
        |CUBE OPEN_PAREN tmp = grouping_column_ref_list CLOSE_PAREN
        |OPEN_PAREN CLOSE_PAREN
        ;

grouping_column_ref_list returns [Vector glist = new Vector()]
        {String tmp; {checkStatus();}}
        :
        tmp = grouping_column_ref {glist.add(tmp);}
        (COMMA tmp = grouping_column_ref {glist.add(tmp);})*
        ;

grouping_column_ref returns [String gcol = ""]
        {String tmp; XExpression exp = null; {checkStatus();}}
        :
        //gcol = column_ref ( tmp = collate_clause {gcol += " " + tmp;})?
        exp= value_exp {gcol = exp.toString();}//( tmp = collate_clause {gcol += " " + tmp;})?
        //|a:UNSIGNED_NUM_LIT {gcol = a.getText();}
        ;

having_clause returns [XFilterNode having = null]
        {checkStatus();}
        :
        HAVING having = search_condition
        ;

table_value_constructor returns [XExpression exp = null]
        {String str; XExpression tmp; {checkStatus();}}
        :
        a:VALUES tmp = table_value_const_list
        {str = a.getText() + " " + tmp.toString(); exp = new XExpression(); exp.setValue(str,XExpression.EXPRESSION);}
        ;

table_value_const_list returns [XExpression exp = null]
        {XExpression tmp; String str = ""; {checkStatus();}}
        :
        tmp = row_value_constructor {str = tmp.toString();}
        ( COMMA tmp = row_value_constructor {str += "," + tmp.toString();})*
        {exp = new XExpression(); exp.setValue(str,XExpression.EXPRESSION);}
        ;

explicit_table returns [XExpression exp = null]
        {String tmp; {checkStatus();}}
        :
        a:TABLE tmp = table_name
        {exp = new XExpression(); exp.setValue(a.getText() + " " + tmp,XExpression.EXPRESSION);}
        ;

query_term returns [XExpression exp = null]
        {checkStatus();}
        :
        (non_join_query_term)=>
        exp = non_join_query_term
        | exp = joined_table
        ;

joined_table_2 [UniformSQL sql] returns [XExpression exp = null]
        {XExpression tmp; {checkStatus();}}
        :
        (table_ref_nojoin[null, null] CROSS)=>
        exp = cross_join[sql]
        |
        (table_ref_nojoin[null, null])=>
        exp = qualified_join[sql]
        | OPEN_PAREN tmp = joined_table_2[sql] CLOSE_PAREN
        {exp = new XExpression(); exp.setValue("("+tmp.toString()+")",XExpression.EXPRESSION); }
        ;

joined_table returns [XExpression exp = null]
        {XExpression tmp; {checkStatus();}}
        :
        (table_ref_nojoin[null, null] CROSS)=>
        exp = cross_join[null]
        |
        (table_ref_nojoin[null, null])=>
        exp = qualified_join[null]
        | OPEN_PAREN tmp = joined_table CLOSE_PAREN
        {exp = new XExpression(); exp.setValue("("+tmp.toString()+")",XExpression.EXPRESSION);}
        ;

cross_join [UniformSQL sql] returns [XExpression exp = null]
        {String tmp, tmp1; {checkStatus();}}
        :
        tmp = table_ref_nojoin[sql, null] a:CROSS b:JOIN tmp1 = table_ref_nojoin[sql, null]
        {tmp += " " + a.getText() + " " + b.getText() + " " + tmp1;
         exp = new XExpression(); exp.setValue(tmp,XExpression.EXPRESSION);
        }
        ;

qualified_join [UniformSQL sql] returns [XExpression exp = null]
        {String tmp, tmp1, str = ""; {checkStatus();}}
        :
        tmp = table_ref_nojoin[sql, null] {str = tmp;}
        tmp = sub_qualified_join[sql] {str += " " + tmp;}
        {exp = new XExpression(); exp.setValue(str, XExpression.EXPRESSION);}
        ;

sub_qualified_join [UniformSQL sql] returns [String str = ""]
        { String tbl2=""; String tmp; String op = ""; String table = ""; XExpression exp = null; {checkStatus();}}
        :
        (
         (
          ( c:NATURAL {str += " " + c.getText();})?
          ( tmp = join_type { op = tmp + " JOIN";
          str += " " + tmp;})?
          d:JOIN {str += " " + d.getText(); }
         )
         |(OJ EQ {str += "(+)=";})
        )
        (
          ((joined_table)=>
            (exp = joined_table_2[sql] {str += exp.toString();})
            |(table = table_ref_nojoin[sql, op] {str += " " + table;
                                                 tbl2 = table;
                                                 tbl2 = tbl2.trim();})
          )
          ( (join_spec[null, "", ""])=>
            tmp = join_spec[sql, op, tbl2] {str += " " + tmp;}
            ((sub_qualified_join[sql])=> tmp = sub_qualified_join[sql] {str += " " + tmp;})?
          )?
        )
        ;

join_hint
        {String tmp; {checkStatus();}}
        :
        (NATURAL)? (tmp=join_type)? JOIN
        |(OJ EQ)
        ;

join_type returns [String jt = ""]
        {checkStatus();}
        :
        a:INNER {jt = a.getText();}
        | jt = outer_join_type ( b:OUTER {jt += " " + b.getText();})?
        | c:UNION {jt += " " + c.getText();}
        ;

outer_join_type returns [String ojt = ""]
        {checkStatus();}
        :
        a:LEFT {ojt = a.getText();}
        | b:RIGHT {ojt = b.getText();}
        | c:FULL {ojt = c.getText();}
        ;

join_spec [UniformSQL sql, String op, String tbl2] returns [String js = ""]
        {checkStatus();}
        :
        js = join_condition[sql, op, tbl2]
        | js = named_columns_join[sql]
        ;

join_condition [UniformSQL sql, String op, String tbl2] returns [String jc = ""]
        {XFilterNode tmp; {checkStatus();}}
        :
        a:ON tmp = search_condition
        {
        jc = a.getText() + " " + tmp.toString();

        if(sql != null) {
           if(op.length() >= 4 && op.substring(0, 4).equalsIgnoreCase("LEFT")) {
              XJoin join = ((XJoin) tmp);
              String op1 = getTableOp(sql, join.getTable1(sql));

              if(op1 != null && op1.substring(0, 4).equalsIgnoreCase("LEFT")) {
                 XExpression exp1 = join.getExpression1();
                 XExpression exp2 = join.getExpression2();
                 join.setExpression1(exp2);
                 join.setExpression2(exp1);
              }

              join.setOp("*=");
           }
           else if(op.length() >= 5 && op.substring(0, 5).equalsIgnoreCase("RIGHT")) {
              XJoin join = ((XJoin) tmp);
              String op1 = getTableOp(sql, join.getTable1(sql));

              if(op1 != null && op1.substring(0, 5).equalsIgnoreCase("RIGHT")) {
                 XExpression exp1 = join.getExpression1();
                 XExpression exp2 = join.getExpression2();
                 join.setExpression1(exp2);
                 join.setExpression2(exp1);
              }

              join.setOp("=*");
           }
           else if(op.length() >= 4 && op.substring(0, 4).equalsIgnoreCase("FULL")) {
              XJoin join = ((XJoin) tmp);
              String op1 = getTableOp(sql, join.getTable1(sql));

              if(op1 != null && op1.substring(0, 4).equalsIgnoreCase("FULL")) {
                 XExpression exp1 = join.getExpression1();
                 XExpression exp2 = join.getExpression2();
                 join.setExpression1(exp2);
                 join.setExpression2(exp1);
              }

              join.setOp("*=*");
           }

           sql.combineWhereByAnd(tmp);
        }

        }
        ;

named_columns_join [UniformSQL sql] returns [String jc = ""]
        {String tmp; Vector list = null; if(sql != null){list = new Vector();} {checkStatus();}}
        :
        a:USING OPEN_PAREN tmp = join_column_list[list] CLOSE_PAREN
        {jc = a.getText() + "(" + tmp + ")";
         if(sql != null && list.size()>0) {
          if(sql.getTableCount()>=2) {
           String t1 = sql.getTableAlias(sql.getTableCount()-2);//get last 2 table
           String t2 = sql.getTableAlias(sql.getTableCount()-1);
           XExpression e1, e2;
           XFilterNode node = ((list.size()>1)?((XFilterNode)new XSet()):((XFilterNode)new XJoin()));
           XJoin tmpNode ;

           node.setName(getUniqueName());

           if(list.size() == 1) {
                e1 = new XExpression(t1+"."+(String)list.elementAt(0),
                                        XExpression.FIELD);
                e2 = new XExpression(t2+"."+(String)list.elementAt(0),
                                        XExpression.FIELD);
                ((XJoin)node).setExpression1(e1);
                ((XJoin)node).setExpression2(e2);
                ((XJoin)node).setOp("=");
           }
           else {
                ((XSet)node).setRelation(XSet.AND);
                for(int i = 0; i < list.size(); i++) {
                        e1 = new XExpression(t1+"."+(String)list.elementAt(i),
                                                XExpression.FIELD);
                        e2 = new XExpression(t2+"."+(String)list.elementAt(i),
                                                XExpression.FIELD);
                        tmpNode = new XJoin();
                        tmpNode.setExpression1(e1);
                        tmpNode.setExpression2(e2);
                        tmpNode.setOp("=");
                        tmpNode.setName(getUniqueName());
                        ((XSet)node).addChild(tmpNode);
                }
           }
           sql.combineWhereByAnd(node);
          }
         }
        }
        ;

join_column_list [Vector list] returns [String jcl = ""]
        {checkStatus();}
        :
        jcl = column_name_list[list]
        ;

corresponding_spec returns [String cs = ""]
        {String tmp; {checkStatus();}}
        :
        a:CORRESPONDING {cs = a.getText();}
        ( b:BY OPEN_PAREN tmp = corresponding_column_list CLOSE_PAREN
        {cs += " " + b.getText() + "(" + tmp + ")";})?
        ;

corresponding_column_list returns [String ccl = ""]
        {checkStatus();}
        :
        ccl = column_name_list[null]
        ;

query_primary returns [XExpression exp = null]
        {checkStatus();}
        :
        (joined_table)=>
         exp = joined_table
        |  exp = non_join_query_primary
        ;

where_clause returns [XFilterNode where = null]
        {checkStatus();}
        :
        WHERE where = search_condition
        ;

order_by_clause [UniformSQL sql] returns [String ret = ""]
      {checkStatus();}
      :
      ORDER BY ret = sort_spec_list[sql]
      {ret = " order by " + ret;}
      ;

sort_spec_list [UniformSQL sql] returns [String ret = ""]
      {String tmp; {checkStatus();}}
      :
      ret = sort_spec[sql]
      ( COMMA tmp = sort_spec[sql] {ret += " ," + tmp;})*
      ;

sort_spec [UniformSQL sql] returns [String ret = ""]
        {Object field; String order = "asc"; String tmp; {checkStatus();}}
        :
        field = sort_key
        //( tmp = collate_clause )?
        ( order = ordering_spec )?
        {if(sql != null)
         {
          sql.setOrderBy(field, order);
         }
         ret = field.toString() + " " + order;
        }
        ;

sort_key returns [Object field = null]
        {String tmp; XExpression exp; {checkStatus();}}
        :
        exp = value_exp
        {
          try {
            field = Integer.valueOf(exp.toString());
          }
          catch(Exception e) {
            field = new String(exp.toString());
          }
        }
        ;

ordering_spec returns [String order = null]
      {checkStatus();}
      :
      a:ASC {order = a.getText();}| b:DESC {order = b.getText();}
      ;

// The following two rules is for test.

select_stmt_single_row_debug
        {JDBCSelection selection; String tmp; {checkStatus();}}
        :
        SELECT
        ( tmp = set_quantifier
        {if(tmp.equalsIgnoreCase("all")){
                uniSql.setAll(true);
        }
        else {
                uniSql.setDistinct(true);
        }})?
        (TOP UNSIGNED_NUM_LIT { uniSql.setLossy(true); } )?
        selection = select_list[uniSql] {uniSql.setSelection(selection);}
        table_exp[uniSql] SEMI
        ;

direct_select_stmt_n_rows_debug [UniformSQL sql]
        {int i = 1; XExpression exp; this.uniSql = sql; {checkStatus();}}
        :
        /*
        ({System.out.print("sql" + i++ + "...");}
        ((select_stmt_single_row_debug)=> select_stmt_single_row_debug
        {System.out.println("ok.");sql = new UniformSQL(); this.uniSql = sql;}
        |(exp = query_exp ( order_by_clause[null] )? SEMI )
        {System.out.println("ok.");}))*
        */

        ({System.out.print("sql" + i++ + "...");}
         select_stmt_single_row_debug
        {System.out.println("ok.");sql = new UniformSQL(); this.uniSql = sql;}
        )*
        ;



// The following two rules is fromal.

select_stmt_single_row
        {JDBCSelection selection; String tmp; {checkStatus();}}
        :
        SELECT
        ( tmp = set_quantifier
        {if(tmp.trim().equalsIgnoreCase("all")){
                uniSql.setAll(true);
        }
        else {
                uniSql.setDistinct(true);
        }})?
        (TOP UNSIGNED_NUM_LIT { uniSql.setLossy(true); } )?
        selection = select_list[uniSql] {uniSql.setSelection(selection);}
        table_exp[uniSql]
        ;

direct_select_stmt_n_rows [UniformSQL sql]
        {XExpression tmp; this.uniSql = sql; {checkStatus();}}
        :
        /*
        (select_stmt_single_row)=> select_stmt_single_row
        |(tmp = query_exp ( order_by_clause[null] )?
        ) (SEMI)?
        */

        select_stmt_single_row (SEMI)?
        ;

//The following rules is for partially parse
only_select [UniformSQL sql] //only parse select clause
        {JDBCSelection selection; String tmp; this.uniSql = sql; {checkStatus();}}
        :
        SELECT
        ( tmp = set_quantifier
        {if(tmp.trim().equalsIgnoreCase("all")){
                sql.setAll(true);
        }
        else {
                sql.setDistinct(true);
        }})?
        (TOP UNSIGNED_NUM_LIT { uniSql.setLossy(true); } )?
        selection = select_list[sql] {sql.setSelection(selection);}
        ;

only_select_from [UniformSQL sql] //only parse select clause and from clause
        {JDBCSelection selection; String tmp; this.uniSql = sql; {checkStatus();}}
        :
        SELECT
        ( tmp = set_quantifier
        {if(tmp.trim().equalsIgnoreCase("all")){
                sql.setAll(true);
        }
        else {
                sql.setDistinct(true);
        }})?
        (TOP UNSIGNED_NUM_LIT { uniSql.setLossy(true); } )?
        selection = select_list[sql] {sql.setSelection(selection);}
        (from_clause[sql])?
        ;

/*
 * This Class is generated by antlr base on gramma file SQLLexer.g
 */
class SQLLexer extends Lexer;
options {
	k=2;
	//importVocab=SuperLexer;
	testLiterals=false;    // don't automatically test for literals
	caseSensitiveLiterals=false;
	charVocabulary='\u0000'..'\uFFFE';
	filter = true;
}

tokens {
	SELECT		= "select";
	ALL		    = "all";
	DISTINCT	= "distinct";
	FROM		= "from";
	WHERE		= "where";

	ANY		    = "any";	// used by quantified_predicate
	SOME		= "some";	// used by quantified_predicate

	AS		    = "as";

	NOT		    = "not"	;
	AND		    = "and"	;
	OR		    = "or"	;

	IS		    = "is";
	TRUE		= "true";
	FALSE		= "false";
	UNKNOWN		= "unknown";

	NULL		= "null";
	NULLIF		= "nullif";
	COALESCE	= "coalesce";
	CASE		= "case";
	END		;
	WHEN		= "when";
	THEN		= "then";
	ELSE		= "else";
	CAST		= "cast";
	OVER		= "over";
	PARTITION	= "partition";

	T_DATE		= "date";
	T_TIME		= "time";
	//ZONE		= "zone";
	INTERVAL	= "interval";
	//TO		= "to";
	SECOND		= "second";
	//POSITION	= "position";
	IN		= "in";

	FOR		= "for";
	USING		= "using";
	//COLLATE		= "collate";
	//EXTRACT		= "extract";
	//TIMEZONE_HOUR	= "timezone_hour";
	//TIMEZONE_MINUTE	= "timezone_minute";
	//CURRENT_DATE	= "current_date";
	//CURRENT_TIME	= "current_time";
	//CURRENT_TIMESTAMP= "current_timestamp";
	//AT		= "at";
	//LOCAL		= "local";

	BETWEEN		= "between";
	ESCAPE		= "escape";
	EXISTS		= "exists";
	UNIQUE		= "unique";
	MATCH		= "match";
	MATCHES		= "matches";
	LIKE		= "like";
	//SIMILAR		= "similar";
	PARTIAL		= "partial";
	FULL		= "full";
	SIMPLE		= "simple";
	OVERLAPS	= "overlaps";
	UNION		= "union";
	EXCEPT		= "except";
	MINUS_STR	= "minus";
	INTERSECT	= "intersect";
	//MODULE		= "module";
	GROUP		= "group";
	BY		= "by";
	HAVING		= "having";
	VALUES		= "values";
	TABLE		= "table";
	CROSS		= "cross";
	JOIN		= "join";
	NATURAL		= "natural";
	INNER		= "inner";
	OUTER		= "outer";
	LEFT		= "left";
	RIGHT		= "right";
	ON		= "on";
	CORRESPONDING	= "corresponding";
	INDICATOR	= "indicator";
	ORDER		= "order";
	ASC		= "asc";
	DESC		= "desc";
	FIELD 		= "field";
	//COUNT		= "count";

	// used by group by clause accroding to SQL3
	ROLLUP		= "rollup";
	CUBE		= "cube";
	GROUPING	= "grouping";
	SETS		= "sets";
	REGEXP 		= "regexp";

	TOP		= "top";

}

{

//private boolean intervalFlag = false;
private boolean intervalEnd = true;

private boolean isInterval() {
	int i = 0; String tmp = "";
	try {
		while(LA(i) == ' ') {
			i--;
		}
		for(int k = 7; k >= 0; k --) {
		tmp += LA(i-k);

		}

		if (tmp.equalsIgnoreCase("interval")) {
			intervalEnd = false;
			return true;
		}
	}
	catch(Exception e) {
	}
	if(intervalEnd == false) {
		intervalEnd = true;
		return true;
	}
	return false;
}
}

/*DIGIT      :
      '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
      ;*/

IDENT
			options {testLiterals=true;}
			:	('a'..'z'|'A'..'Z'|'\u0100'..'\uFFFE'|'@') ('a'..'z'|'A'..'Z'|'\u0100'..'\uFFFE'|'_'|'0'..'9')*
			;

SPIDENT			:	'"'(~('"'))*'"'
			;
SPIDENT2		:	'`' ('\u0001'..'\u005f' | '\u0061'..'\ufffe')* '`'
			;

SPIDENT_VAR             :    "$(" ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|' '|
                                  '+' | '-' |'@'|'\u0100'..'\uFFFE')* ')' ;

//have not include all chinese character
SPIDENT_SQUARE		: 	'['
				(('\u0001'..'\u005a'|('\u005E'..'\u7fff')
				|('\u8001'..'\u803f')|('\u8041'..'\u807f')
				|('\u8081'..'\u80bf')|('\u80c1'..'\u80fd')
				))*
				']'
			;

SPIDENT_BRACKET		:	'{' ('\u0001'..'\u007a' | '\u007c' | '\u007e'..'\ufffe')* '}'
			;

WS			:	(' '
			|	'\t'
			|	'\n'	{newline();}
			|	'\r')
				{ _ttype = Token.SKIP; }
			;

COMMA			:	',' ;
DOT			:	'.' ;
SEMI			:	';' ;
STAR			:	'*' ;
DIV			:	'/' ;
PLUS			:	'+' ;
MINUS			:	'-' ;
QUESTION_MARK		: 	'?' ;
OPEN_PAREN		:	'(' ;
CLOSE_PAREN		:	')' ;
INTRODUCER		:	'_' ;
COLON			:	':' ;
DOLAR			:	'$' ;

protected
SINGLE_QUOTE		:	'\'';

/*NUMBER
	:
	(
	('0'..'9')+ (DOT ('0'..'9')+)? (EXPONENT)?
	)
	;                                               */

//Date format should be 'yyyy-mm-dd'
protected
DATE
	:
	'\''
	('0'..'9')('0'..'9')('0'..'9')('0'..'9')
	'-'
	(('0')('0'..'9')|('1')('0'..'2'))
	'-'
	(('0'|'1'|'2')('0'..'9')|('3')('0'|'1'))
	'\''
	;

//Time format should be 'hh:mm:ss[.[nnnnnn]][<time zone interval>]'
protected
TIME
	:
	(
	'\''
	(('0'..'1')('0'..'9')|('2')('0'..'3'))	//hh
	':'
	('0'..'5')('0'..'9')			//mm
	':'
	(('0'..'5')('0'..'9')|('6')('0'|'1'))	//ss
	('.'(('0'..'9'))*)?
	'\''
	);


// The STRING_LITERAL role come form java.g a example of antlr
// string literals
STRING_LITERAL
	:
	(TIME)=>
	 TIME { _ttype = TIME; }
	|(DATE)=>
	 DATE { _ttype = DATE; }
	| {isInterval() == false}? '\'' (~('\''|'"'))* '\''
	| '\'' { _ttype = SINGLE_QUOTE; }
	;

UNSIGNED_NUM_LIT
	:
	(APPROXIMATE_NUM)=>
	APPROXIMATE_NUM
	| EXACT_NUM
	;

protected
APPROXIMATE_NUM
	:
	EXACT_NUM EXPONENT
	;

protected
EXACT_NUM
	:
	UNSIGNED_INT ('.' (UNSIGNED_INT)?)?
	//|'.' UNSIGNED_INT
	;

protected
UNSIGNED_INT
	:
	('0'..'9') ('0'..'9')*
	;

protected
EXPONENT
	:	('e'|'E') ('+'|'-')? ('0'..'9')+
	;

// The ESC role come form java.g a example of antlr
// escape sequence -- note that this is protected; it can only be called
//   from another lexer rule -- it will not ever directly return a token to
//   the parser
// There are various ambiguities hushed in this rule.  The optional
// '0'...'9' digit matches should be matched here rather than letting
// them go back to STRING_LITERAL to be matched.  ANTLR does the
// right thing by matching immediately; hence, it's ok to shut off
// the FOLLOW ambig warnings.
protected
ESC
	:	'\\'
		(	'n'
		|	'r'
		|	't'
		|	'b'
		|	'f'
		|	'"'
		|	'\''
		|	'\\'
		|	('u')+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
		|	('0'..'3')
			(
				options {
					warnWhenFollowAmbig = false;
				}
			:	('0'..'7')
				(
					options {
						warnWhenFollowAmbig = false;
					}
				:	'0'..'7'
				)?
			)?
		|	('4'..'7')
			(
				options {
					warnWhenFollowAmbig = false;
				}
			:	('0'..'9')
			)?
		)
	;


// The HEX_DIGIT role come form java.g a example of antlr
// hexadecimal digit (again, note it's protected!)
protected
HEX_DIGIT
	:	('0'..'9'|'A'..'F'|'a'..'f')
	;

// Single-line comments
SL_COMMENT
	:	"//"
		//(~('\n'|'\r'))* ('\n'|'\r'('\n')?)
		('\u0000'..'\u0009'|'\u000B'|'\u000C'|'\u000E'..'\uFFFE')* ('\n'|'\r'('\n')?)
		{$setType(Token.SKIP); newline();}
		|
		"--"
		//(~('\n'|'\r'))* ('\n'|'\r'('\n')?)
		('\u0000'..'\u0009'|'\u000B'|'\u000C'|'\u000E'..'\uFFFE')* ('\n'|'\r'('\n')?)
		{$setType(Token.SKIP); newline();}
	;

// multiple-line comments
ML_COMMENT
	:	"/*"
		(	/*	'\r' '\n' can be matched in one alternative or by matching
				'\r' in one iteration and '\n' in another.  I am trying to
				handle any flavor of newline that comes in, but the language
				that allows both "\r\n" and "\r" and "\n" to all be valid
				newline is ambiguous.  Consequently, the resulting grammar
				must be ambiguous.  I'm shutting this warning off.
			 */
			options {
				generateAmbigWarnings=false;
			}
		:
			{ LA(2)!='/' }? '*'
		|	'\r' '\n'		{newline();}
		|	'\r'			{newline();}
		|	'\n'			{newline();}
		//|	~('*'|'\n'|'\r')
		|	'\u0000'..'\u0009'|'\u000B'|'\u000C'|'\u000E'..'\u0029'|'\u002B'..'\uFFFE'
		)*
		"*/"
		{$setType(Token.SKIP);}
	;

EQ      :       "=" 	;
GE      :       ">="	;
GT      :       ">" 	;
LE      :       "<="	;
LT_     :       "<" 	;
NE      :       "!="	;
NEQ     :       "<>"	;
LJ	:	"*="	;	//left join
RJ	:	"=*"	;	//right join
OJ	:	"(+)"	;	//oracle join
COLON_EQU	:	":=";

CONCATENATION_OP	:	"||" | "&";
